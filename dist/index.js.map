{"version":3,"sources":["../src/core.ts","../src/serialize.ts","../src/rpc.ts","../src/websocket.ts","../src/batch.ts","../src/messageport.ts","../src/map.ts","../src/index.ts"],"names":["err","hook","RpcStub","RpcPromise","RpcSession","RpcTarget","newWebSocketRpcSession","newHttpBatchRpcSession","newMessagePortRpcSession"],"mappings":"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","file":"index.js","sourcesContent":["// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport type { RpcTargetBranded, __RPC_TARGET_BRAND } from \"./types.js\";\r\n\r\n// Polyfill Symbol.dispose for browsers that don't support it yet\r\nif (!Symbol.dispose) {\r\n  (Symbol as any).dispose = Symbol.for('dispose');\r\n}\r\nif (!Symbol.asyncDispose) {\r\n  (Symbol as any).asyncDispose = Symbol.for('asyncDispose');\r\n}\r\n\r\nlet workersModuleName = navigator.userAgent === \"Cloudflare-Workers\" ? \"cloudflare:workers\" : null;\r\nlet workersModule: any;\r\nif (workersModuleName) {\r\n  workersModule = await import(/* @vite-ignore */workersModuleName);\r\n}\r\n\r\nexport interface RpcTarget {\r\n  [__RPC_TARGET_BRAND]: never;\r\n};\r\n\r\nexport let RpcTarget = workersModule ? workersModule.RpcTarget : class {};\r\n\r\nexport type PropertyPath = (string | number)[];\r\n\r\ntype TypeForRpc = \"unsupported\" | \"primitive\" | \"object\" | \"function\" | \"array\" | \"date\" |\r\n    \"bigint\" | \"bytes\" | \"stub\" | \"rpc-promise\" | \"rpc-target\" | \"rpc-thenable\" | \"error\" |\r\n    \"undefined\";\r\n\r\nexport function typeForRpc(value: unknown): TypeForRpc {\r\n  switch (typeof value) {\r\n    case \"boolean\":\r\n    case \"number\":\r\n    case \"string\":\r\n      return \"primitive\";\r\n\r\n    case \"undefined\":\r\n      return \"undefined\";\r\n\r\n    case \"object\":\r\n    case \"function\":\r\n      // Test by prototype, below.\r\n      break;\r\n\r\n    case \"bigint\":\r\n      return \"bigint\";\r\n\r\n    default:\r\n      return \"unsupported\";\r\n  }\r\n\r\n  // Ugh JavaScript, why is `typeof null` equal to \"object\" but null isn't otherwise anything like\r\n  // an object?\r\n  if (value === null) {\r\n    return \"primitive\";\r\n  }\r\n\r\n  // Aside from RpcTarget, we generally don't support serializing *subclasses* of serializable\r\n  // types, so we switch on the exact prototype rather than use `instanceof` here.\r\n  let prototype = Object.getPrototypeOf(value);\r\n  switch (prototype) {\r\n    case Object.prototype:\r\n      return \"object\";\r\n\r\n    case Function.prototype:\r\n      return \"function\";\r\n\r\n    case Array.prototype:\r\n      return \"array\";\r\n\r\n    case Date.prototype:\r\n      return \"date\";\r\n\r\n    case Uint8Array.prototype:\r\n      return \"bytes\";\r\n\r\n    // TODO: All other structured clone types.\r\n\r\n    case RpcStub.prototype:\r\n      return \"stub\";\r\n\r\n    case RpcPromise.prototype:\r\n      return \"rpc-promise\";\r\n\r\n    // TODO: Promise<T> or thenable\r\n\r\n    default:\r\n      if (workersModule) {\r\n        // TODO: We also need to match `RpcPromise` and `RpcProperty`, but they currently aren't\r\n        //   exported by cloudflare:workers.\r\n        if (prototype == workersModule.RpcStub.prototype ||\r\n            value instanceof workersModule.ServiceStub) {\r\n          return \"rpc-target\";\r\n        } else if (prototype == workersModule.RpcPromise.prototype ||\r\n                   prototype == workersModule.RpcProperty.prototype) {\r\n          // Like rpc-target, but should be wrapped in RpcPromise, so that it can be pull()ed,\r\n          // which will await the thenable.\r\n          return \"rpc-thenable\";\r\n        }\r\n      }\r\n\r\n      if (value instanceof RpcTarget) {\r\n        return \"rpc-target\";\r\n      }\r\n\r\n      if (value instanceof Error) {\r\n        return \"error\";\r\n      }\r\n\r\n      return \"unsupported\";\r\n  }\r\n}\r\n\r\nfunction mapNotLoaded(): never {\r\n  throw new Error(\"RPC map() implementation was not loaded.\");\r\n}\r\n\r\n// map() is implemented in `map.ts`. We can't import it here because it would create an import\r\n// cycle, so instead we define two hook functions that map.ts will overwrite when it is imported.\r\nexport let mapImpl: MapImpl = { applyMap: mapNotLoaded, sendMap: mapNotLoaded };\r\n\r\ntype MapImpl = {\r\n  // Applies a map function to an input value (usually an array).\r\n  applyMap(input: unknown, parent: object | undefined, owner: RpcPayload | null,\r\n           captures: StubHook[], instructions: unknown[])\r\n          : StubHook;\r\n\r\n  // Implements the .map() method of RpcStub.\r\n  sendMap(hook: StubHook, path: PropertyPath, func: (value: RpcPromise) => unknown)\r\n         : RpcPromise;\r\n}\r\n\r\n// Inner interface backing an RpcStub or RpcPromise.\r\n//\r\n// A hook may eventually resolve to a \"payload\".\r\n//\r\n// Declared as `abstract class` to allow `instanceof StubHook`, used by `RpcStub` constructor.\r\n//\r\n// This is conceptually similar to the Cap'n Proto C++ class `ClientHook`.\r\nexport abstract class StubHook {\r\n  // Call a function at the given property path with the given arguments. Returns a hook for the\r\n  // promise for the result.\r\n  abstract call(path: PropertyPath, args: RpcPayload): StubHook;\r\n\r\n  // Apply a map operation.\r\n  //\r\n  // `captures` is a list of external stubs which are used as part of the mapper function.\r\n  // NOTE: The callee takes ownership of `captures`.\r\n  //\r\n  // `instructions` is a JSON-serializable value describing the mapper function as a series of\r\n  // steps. Each step is an expression to evaluate, in the usual RPC expression format. The last\r\n  // instruction is the return value.\r\n  //\r\n  // Each instruction can refer to the results of any of the instructions before it, as well as to\r\n  // the captures, as if they were imports on the import table. In particular:\r\n  // * The value 0 is the input to the mapper function (e.g. one element of the array being mapped).\r\n  // * Positive values are 1-based indexes into the instruction table, representing the results of\r\n  //   previous instructions.\r\n  // * Negative values are -1-based indexes into the capture list.\r\n  abstract map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook;\r\n\r\n  // Read the property at the given path. Returns a StubHook representing a promise for that\r\n  // property. This behaves very similarly to call(), except that no actual function is invoked\r\n  // on the remote end, the property is simply returned. (Well, if the property has a getter, then\r\n  // that will be invoked...)\r\n  //\r\n  // (In the case that this stub is a promise with a resolution payload, get() implies cloning\r\n  // a branch of the payload, making a deep copy of any pass-by-value content.)\r\n  abstract get(path: PropertyPath): StubHook;\r\n\r\n  // Create a clone of this StubHook, which can be disposed independently.\r\n  //\r\n  // The returned hook is NOT considered a promise, so will not resolve to a payload (you can use\r\n  // `get([])` to get a promise for a cloned payload).\r\n  abstract dup(): StubHook;\r\n\r\n  // Requests resolution of a StubHook that represents a promise, and eventually produces the\r\n  // payload.\r\n  //\r\n  // pull() should not be called on capabilities that aren't promises. It may never resolve or it\r\n  // may throw an exception.\r\n  //\r\n  // If pull() is never called (on a remote promise), the RPC system will not transmit the\r\n  // resolution at all. This allows a promise to be used strictly for pipelining.\r\n  //\r\n  // If the payload is already available, pull() returns it immediately, instead of returning a\r\n  // promise. This allows the caller to skip the microtask queue which is sometimes necessary to\r\n  // maintain e-order guarantees.\r\n  //\r\n  // The returned RpcPayload is the same one backing the StubHook itself. If the caller delivers\r\n  // or disposes the payload directly, then it should not call dispose() on the hook. If the caller\r\n  // does not intend to consume the StubHook, the caller must take responsibility for cloning the\r\n  // payload.\r\n  //\r\n  // You can call pull() multiple times, but it will return the same RpcPayload every time, and\r\n  // that payload should only be disposed once.\r\n  //\r\n  // If pull() returns a promise which rejects, the StubHook does not need to be disposed.\r\n  abstract pull(): RpcPayload | Promise<RpcPayload>;\r\n\r\n  // Called to prevent this stub from generating unhandled rejection events if it throws without\r\n  // having been pulled. Without this, if a client \"push\"es a call that immediately throws before\r\n  // the client manages to \"pull\" it or use it in a pipeline, this may be treated by the system as\r\n  // an unhandled rejection. Unfortunately, this unhandled rejection would be reported in the\r\n  // callee rather than the caller, possibly causing the callee to crash or log spurious errors,\r\n  // even though it's really up to the caller to deal with the exception!\r\n  abstract ignoreUnhandledRejections(): void;\r\n\r\n  // Attempts to cancel any outstanding promise backing this hook, and disposes the payload that\r\n  // pull() would return (if any). If a pull() promise is outstanding, it may still resolve (with\r\n  // a disposed payload) or it may reject. It's safe to call dispose() multiple times.\r\n  abstract dispose(): void;\r\n\r\n  abstract onBroken(callback: (error: any) => void): void;\r\n}\r\n\r\nexport class ErrorStubHook extends StubHook {\r\n  constructor(private error: any) { super(); }\r\n\r\n  call(path: PropertyPath, args: RpcPayload): StubHook { return this; }\r\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook { return this; }\r\n  get(path: PropertyPath): StubHook { return this; }\r\n  dup(): StubHook { return this; }\r\n  pull(): RpcPayload | Promise<RpcPayload> { return Promise.reject(this.error); }\r\n  ignoreUnhandledRejections(): void {}\r\n  dispose(): void {}\r\n  onBroken(callback: (error: any) => void): void {\r\n    try {\r\n      callback(this.error);\r\n    } catch (err) {\r\n      // Don't throw back into the RPC system. Treat this as an unhandled rejection.\r\n      Promise.resolve(err);\r\n    }\r\n  }\r\n};\r\n\r\nconst DISPOSED_HOOK: StubHook = new ErrorStubHook(\r\n    new Error(\"Attempted to use RPC stub after it has been disposed.\"));\r\n\r\n// A call interceptor can be used to intercept all RPC stub invocations within some synchronous\r\n// scope. This is used to implement record/replay\r\ntype CallInterceptor = (hook: StubHook, path: PropertyPath, params: RpcPayload) => StubHook;\r\nlet doCall: CallInterceptor = (hook: StubHook, path: PropertyPath, params: RpcPayload) => {\r\n  return hook.call(path, params);\r\n}\r\n\r\nexport function withCallInterceptor<T>(interceptor: CallInterceptor, callback: () => T): T {\r\n  let oldValue = doCall;\r\n  doCall = interceptor;\r\n  try {\r\n    return callback();\r\n  } finally {\r\n    doCall = oldValue;\r\n  }\r\n}\r\n\r\n// Private symbol which may be used to unwrap the real stub through the Proxy.\r\nlet RAW_STUB = Symbol(\"realStub\");\r\n\r\nexport interface RpcStub extends Disposable {\r\n  // Declare magic `RAW_STUB` key that unwraps the proxy.\r\n  [RAW_STUB]: this;\r\n}\r\n\r\nconst PROXY_HANDLERS: ProxyHandler<{raw: RpcStub}> = {\r\n  apply(target: {raw: RpcStub}, thisArg: any, argumentsList: any[]) {\r\n    let stub = target.raw;\r\n    return new RpcPromise(doCall(stub.hook,\r\n        stub.pathIfPromise || [], RpcPayload.fromAppParams(argumentsList)), []);\r\n  },\r\n\r\n  get(target: {raw: RpcStub}, prop: string | symbol, receiver: any) {\r\n    let stub = target.raw;\r\n    if (prop === RAW_STUB) {\r\n      return stub;\r\n    } else if (prop in RpcPromise.prototype) {\r\n      // Any method or property declared on RpcPromise (including inherited from RpcStub or\r\n      // Object) should pass through to the target object, as trying to turn these into RPCs will\r\n      // likely be problematic.\r\n      //\r\n      // Note we don't just check `prop in target` because we intentionally want to hide the\r\n      // properties `hook` and `path`.\r\n      return (<any>stub)[prop];\r\n    } else if (typeof prop === \"string\") {\r\n      // Return promise for property.\r\n      return new RpcPromise(stub.hook,\r\n          stub.pathIfPromise ? [...stub.pathIfPromise, prop] : [prop]);\r\n    } else if (prop === Symbol.dispose &&\r\n          (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\r\n      // We only advertise Symbol.dispose on stubs and root promises, not properties.\r\n      return () => {\r\n        stub.hook.dispose();\r\n        stub.hook = DISPOSED_HOOK;\r\n      };\r\n    } else {\r\n      return undefined;\r\n    }\r\n  },\r\n\r\n  has(target: {raw: RpcStub}, prop: string | symbol) {\r\n    let stub = target.raw;\r\n    if (prop === RAW_STUB) {\r\n      return true;\r\n    } else if (prop in RpcPromise.prototype) {\r\n      return prop in stub;\r\n    } else if (typeof prop === \"string\") {\r\n      return true;\r\n    } else if (prop === Symbol.dispose &&\r\n          (!stub.pathIfPromise || stub.pathIfPromise.length == 0)) {\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  },\r\n\r\n  construct(target: {raw: RpcStub}, args: any) {\r\n    throw new Error(\"An RPC stub cannot be used as a constructor.\");\r\n  },\r\n\r\n  defineProperty(target: {raw: RpcStub}, property: string | symbol, attributes: PropertyDescriptor)\r\n      : boolean {\r\n    throw new Error(\"Can't define properties on RPC stubs.\");\r\n  },\r\n\r\n  deleteProperty(target: {raw: RpcStub}, p: string | symbol): boolean {\r\n    throw new Error(\"Can't delete properties on RPC stubs.\");\r\n  },\r\n\r\n  getOwnPropertyDescriptor(target: {raw: RpcStub}, p: string | symbol): PropertyDescriptor | undefined {\r\n    // Treat all properties as prototype properties. That's probably fine?\r\n    return undefined;\r\n  },\r\n\r\n  getPrototypeOf(target: {raw: RpcStub}): object | null {\r\n    return Object.getPrototypeOf(target.raw);\r\n  },\r\n\r\n  isExtensible(target: {raw: RpcStub}): boolean {\r\n    return false;\r\n  },\r\n\r\n  ownKeys(target: {raw: RpcStub}): ArrayLike<string | symbol> {\r\n    return [];\r\n  },\r\n\r\n  preventExtensions(target: {raw: RpcStub}): boolean {\r\n    // Extensions are not possible anyway.\r\n    return true;\r\n  },\r\n\r\n  set(target: {raw: RpcStub}, p: string | symbol, newValue: any, receiver: any): boolean {\r\n    throw new Error(\"Can't assign properties on RPC stubs.\");\r\n  },\r\n\r\n  setPrototypeOf(target: {raw: RpcStub}, v: object | null): boolean {\r\n    throw new Error(\"Can't override prototype of RPC stubs.\");\r\n  },\r\n};\r\n\r\n// Implementation of RpcStub.\r\n//\r\n// Note that the in the public API, we override the type of RpcStub to reflect the interface\r\n// exposed by the proxy. That happens in index.ts. But for internal purposes, it's easier to just\r\n// omit the type parameter.\r\nexport class RpcStub extends RpcTarget {\r\n  // Although `hook` and `path` are declared `public` here, they are effectively hidden by the\r\n  // proxy.\r\n  constructor(hook: StubHook, pathIfPromise?: PropertyPath) {\r\n    super();\r\n\r\n    if (!(hook instanceof StubHook)) {\r\n      // Application invoked the constructor to explicitly construct a stub backed by some value\r\n      // (usually an RpcTarget). (Note we override the types as seen by the app, which is why\r\n      // the app can pass something that isn't a StubHook -- within the implementation, though,\r\n      // we always pass StubHook.)\r\n      let value = <any>hook;\r\n      if (value instanceof RpcTarget || value instanceof Function) {\r\n        hook = TargetStubHook.create(value, undefined);\r\n      } else {\r\n        // We adopt the value with \"return\" semantics since we want to take ownership of any stubs\r\n        // within.\r\n        hook = new PayloadStubHook(RpcPayload.fromAppReturn(value));\r\n      }\r\n\r\n      // Don't let app set this.\r\n      if (pathIfPromise) {\r\n        throw new TypeError(\"RpcStub constructor expected one argument, received two.\");\r\n      }\r\n    }\r\n\r\n    this.hook = hook;\r\n    this.pathIfPromise = pathIfPromise;\r\n\r\n    // Proxy has an unfortunate rule that it will only be considered callable if the underlying\r\n    // `target` is callable, i.e. a function. So our target *must* be callable. So we use a\r\n    // dummy function.\r\n    let func: any = () => {};\r\n    func.raw = this;\r\n    return new Proxy(func, PROXY_HANDLERS);\r\n  }\r\n\r\n  public hook: StubHook;\r\n  public pathIfPromise?: PropertyPath;\r\n\r\n  dup(): RpcStub {\r\n    // Unfortunately the method will be invoked with `this` being the Proxy, not the `RpcPromise`\r\n    // itself, so we have to unwrap it.\r\n\r\n    // Note dup() intentionally resets the path to empty and turns the result into a stub.\r\n    // TODO: Maybe it should actually return the same type? But I think that's not what it does\r\n    //   in Workers RPC today? (Need to check.) Alternatively, should there be an optional\r\n    //   parameter to specify promise vs. stub?\r\n    let target = this[RAW_STUB];\r\n    if (target.pathIfPromise) {\r\n      return new RpcStub(target.hook.get(target.pathIfPromise));\r\n    } else {\r\n      return new RpcStub(target.hook.dup());\r\n    }\r\n  }\r\n\r\n  onRpcBroken(callback: (error: any) => void) {\r\n    this[RAW_STUB].hook.onBroken(callback);\r\n  }\r\n\r\n  map(func: (value: RpcPromise) => unknown): RpcPromise {\r\n    let {hook, pathIfPromise} = this[RAW_STUB];\r\n    return mapImpl.sendMap(hook, pathIfPromise || [], func);\r\n  }\r\n}\r\n\r\nexport class RpcPromise extends RpcStub {\r\n  // TODO: Support passing target value or promise to constructor.\r\n  constructor(hook: StubHook, pathIfPromise: PropertyPath) {\r\n    super(hook, pathIfPromise);\r\n  }\r\n\r\n  then(onfulfilled?: ((value: unknown) => unknown) | undefined | null,\r\n       onrejected?: ((reason: any) => unknown) | undefined | null)\r\n       : Promise<unknown> {\r\n    return pullPromise(this).then(...arguments);\r\n  }\r\n\r\n  catch(onrejected?: ((reason: any) => unknown) | undefined | null): Promise<unknown> {\r\n    return pullPromise(this).catch(...arguments);\r\n  }\r\n\r\n  finally(onfinally?: (() => void) | undefined | null): Promise<unknown> {\r\n    return pullPromise(this).finally(...arguments);\r\n  }\r\n}\r\n\r\n// Given a stub (still wrapped in a Proxy), extract the underlying `StubHook`.\r\n//\r\n// The caller takes ownership, meaning it's expected that the original stub will never be disposed\r\n// itself, but the caller is responsible for calling `dispose()` on the returned hook.\r\n//\r\n// However, if the stub points to a property of some other stub or promise, then no ownership is\r\n// \"transferred\" because properties do not actually have disposers. However, the returned hook is\r\n// a new hook that aliases that property, but does actually need to be disposed.\r\n//\r\n// The result is a promise (i.e. can be pull()ed) if and only if the input is a promise.\r\nexport function unwrapStubTakingOwnership(stub: RpcStub): StubHook {\r\n  let {hook, pathIfPromise} = stub[RAW_STUB];\r\n\r\n  if (pathIfPromise && pathIfPromise.length > 0) {\r\n    return hook.get(pathIfPromise);\r\n  } else {\r\n    return hook;\r\n  }\r\n}\r\n\r\n// Given a stub (still wrapped in a Proxy), extract the underlying `StubHook`, and duplicate it,\r\n// returning the duplicate.\r\n//\r\n// The caller is responsible for disposing the returned hook, but the original stub also still\r\n// needs to be disposed by its owner (unless it is a property, which never needs disposal).\r\n//\r\n// The result is a promise (i.e. can be pull()ed) if and only if the input is a promise. Note that\r\n// this differs from the semantics of the actual `dup()` method.\r\nexport function unwrapStubAndDup(stub: RpcStub): StubHook {\r\n  let {hook, pathIfPromise} = stub[RAW_STUB];\r\n\r\n  if (pathIfPromise) {\r\n    return hook.get(pathIfPromise);\r\n  } else {\r\n    return hook.dup();\r\n  }\r\n}\r\n\r\n// Unwrap a stub returning the underlying `StubHook`, returning `undefined` if it is a property\r\n// stub.\r\n//\r\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\r\n// eventually be disposed (unless `undefined` is returned, in which case neither need to be\r\n// disposed, as properties are not normally disposable).\r\nexport function unwrapStubNoProperties(stub: RpcStub): StubHook | undefined {\r\n  let {hook, pathIfPromise} = stub[RAW_STUB];\r\n\r\n  if (pathIfPromise && pathIfPromise.length > 0) {\r\n    return undefined;\r\n  }\r\n\r\n  return hook;\r\n}\r\n\r\n// Unwrap a stub returning the underlying `StubHook`. If it's a property, return the `StubHook`\r\n// representing the stub or promise of which is is a property.\r\n//\r\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\r\n// eventually be disposed.\r\nexport function unwrapStubOrParent(stub: RpcStub): StubHook {\r\n  return stub[RAW_STUB].hook;\r\n}\r\n\r\n// Given a stub (still wrapped in a Proxy), extract the `hook` and `pathIfPromise` properties.\r\n//\r\n// This function is agnostic to ownership transfer. Exactly one of `stub` or the return `hook` must\r\n// eventually be disposed.\r\nexport function unwrapStubAndPath(stub: RpcStub): {hook: StubHook, pathIfPromise?: PropertyPath} {\r\n  return stub[RAW_STUB];\r\n}\r\n\r\n// Given a promise stub (still wrapped in a Proxy), pull the remote promise and deliver the\r\n// payload. This is a helper used to implement the then/catch/finally methods of RpcPromise.\r\nasync function pullPromise(promise: RpcPromise): Promise<unknown> {\r\n  let {hook, pathIfPromise} = promise[RAW_STUB];\r\n  if (pathIfPromise!.length > 0) {\r\n    // If this isn't the root promise, we have to clone it and pull the clone. This is a little\r\n    // weird in terms of disposal: There's no way for the app to dispose/cancel the promise while\r\n    // waiting because it never actually got a direct disposable reference. It has to dispose\r\n    // the result.\r\n    hook = hook.get(pathIfPromise!);\r\n  }\r\n  let payload = await hook.pull();\r\n  return payload.deliverResolve();\r\n}\r\n\r\n// =======================================================================================\r\n// RpcPayload\r\n\r\nexport type LocatedPromise = {parent: object, property: string | number, promise: RpcPromise};\r\n\r\n// Represents the params to an RPC call, or the resolution of an RPC promise, as it passes\r\n// through the system.\r\n//\r\n// `RpcPayload` is a linear type -- it is passed to or returned from a call, ownership is being\r\n// transferred. The payload in turn owns all the stubs within it. Disposing the payload disposes\r\n// the stubs.\r\n//\r\n// Hypothetically, when an `RpcPayload` is first constructed from a message structure passed from\r\n// the app, it ought to be deep-copied, for a few reasons:\r\n// - To ensure subsequent modifications of the data structure by the app aren't reflected in the\r\n//   already-sent message.\r\n// - To find all stubs in the message tree, to take ownership of them.\r\n// - To find all RpcTargets in the message tree, to wrap them in stubs.\r\n//\r\n// However, most payloads are immediately serialized to send across the wire. Said serialization\r\n// *also* has to make a deep copy, and takes ownership of all stubs found within. In the case that\r\n// the payload is immediately serialized, then making a deep copy first is wasteful.\r\n//\r\n// So, as an optimization, RpcPayload does not necessarily make a copy right away. Instead, it\r\n// keeps track of whether it's still pointing at the message structure received directly from the\r\n// app. In that case, the serializer can operate on the original structure directly, making it\r\n// more efficient.\r\n//\r\n// On the receiving end, when an RpcPayload is deserialized from the wire, the payload can safely\r\n// be delivered directly to the app without a copy. However, if the app makes a loopback call to\r\n// itself, the payload may never cross the wire. In this case, a deep copy must be made before\r\n// delivering the final message to the app. There are really two reasons for this copy:\r\n// - We obviously don't want the caller and callee sharing in-memory mutable data structures, as\r\n//   this would lead to vasty different behavior than what you'd see when doing RPC across a\r\n//   network connection.\r\n// - Before delivering the message to the application, all promises embedded in the message must\r\n//   be resolved. This is what makes pipelining possible: the sender of a message can place\r\n//   `RpcPromise`s in it that refer back to values in the recipient's process. These will be filled\r\n//   in just before delivering the message to the recipient, so that there's no need to transmit\r\n//   these values back and forth across the wire. It would be unreasonable to expect the\r\n//   application itself to check the message for promises and resolve them all, so instead the\r\n//   system automatically resolves all promises upfront, replacing them with their resolutions.\r\n//   This modifies the payload in-place -- but this of course requires that the payload is\r\n//   operating on a copy of the message, not the original provided from the sending app.\r\n//\r\n// For both the purposes of disposal and substituting promises with their resolutions, it is\r\n// necessary at some point to make a list of all the stubs (including promise stubs) present in\r\n// the message. Again, `RpcPayload` tries to minimize the number of times that the whole message\r\n// needs to be walked, so it implements the following policy:\r\n// * When constructing a payload from an app-provided message object, the message is not walked\r\n//   upfront. We do not know yet what stubs it contains.\r\n// * When deserializing a payload from the wire, we build a list of stubs as part of the\r\n//   deserialization process.\r\n// * If we need to deep-copy an app-provided message, we make a list of stubs then.\r\n// * Hence, we have a list of stubs if and only if the message structure was NOT provided directly\r\n//   by the application.\r\n// * If an app-provided payload is serialized, the serializer finds the stubs. (It also typically\r\n//   takes ownership of the stubs, effectively consuming the payload, so there's no need to build\r\n//   a list of the stubs.)\r\n// * If an app-provided payload is disposed, then we have to walk the message at that time to\r\n//   dispose all stubs within. But, note that when a payload is serialized -- with the serializer\r\n//   taking ownership of stubs -- then the payload will NOT be disposed explicitly, so this step\r\n//   will not be needed.\r\nexport class RpcPayload {\r\n  // Create a payload from a value passed as params to an RPC from the app.\r\n  //\r\n  // The payload does NOT take ownership of any stubs in `value`, and but promises not to modify\r\n  // `value`. If the payload is delivered locally, `value` will be deep-copied first, so as not\r\n  // to have the sender and recipient end up sharing the same mutable object. `value` will not be\r\n  // touched again after the call returns synchronously (returns a promise) -- by that point,\r\n  // the value has either been copied or serialized to the wire.\r\n  public static fromAppParams(value: unknown): RpcPayload {\r\n    return new RpcPayload(value, \"params\");\r\n  }\r\n\r\n  // Create a payload from a value return from an RPC implementation by the app.\r\n  //\r\n  // Unlike fromAppParams(), in this case the payload takes ownership of all stubs in `value`, and\r\n  // may hold onto `value` for an arbitrarily long time (e.g. to serve pipelined requests). It\r\n  // will still avoid modifying `value` and will make a deep copy if it is delivered locally.\r\n  public static fromAppReturn(value: unknown): RpcPayload {\r\n    return new RpcPayload(value, \"return\");\r\n  }\r\n\r\n  // Combine an array of payloads into a single payload whose value is an array. Ownership of all\r\n  // stubs is transferred from the inputs to the outputs, hence if the output is disposed, the\r\n  // inputs should not be. (In case of exception, nothing is disposed, though.)\r\n  public static fromArray(array: RpcPayload[]): RpcPayload {\r\n    let stubs: RpcStub[] = [];\r\n    let promises: LocatedPromise[] = [];\r\n\r\n    let resultArray: unknown[] = [];\r\n\r\n    for (let payload of array) {\r\n      payload.ensureDeepCopied();\r\n      for (let stub of payload.stubs!) {\r\n        stubs.push(stub);\r\n      }\r\n      for (let promise of payload.promises!) {\r\n        if (promise.parent === payload) {\r\n          // This promise is the root of the source payload. We need to reparent it to its proper\r\n          // location in the result array.\r\n          promise = {\r\n            parent: resultArray,\r\n            property: resultArray.length,\r\n            promise: promise.promise\r\n          };\r\n        }\r\n        promises.push(promise);\r\n      }\r\n      resultArray.push(payload.value);\r\n    }\r\n\r\n    return new RpcPayload(resultArray, \"owned\", stubs, promises);\r\n  }\r\n\r\n  // Create a payload from a value parsed off the wire using Evaluator.evaluate().\r\n  //\r\n  // A payload is constructed with a null value and the given stubs and promises arrays. The value\r\n  // is expected to be filled in by the evaluator, and the stubs and promises arrays are expected\r\n  // to be extended with stubs found during parsing. (This weird usage model is necessary so that\r\n  // if the root value turns out to be a promise, its `parent` in `promises` can be the payload\r\n  // object itself.)\r\n  //\r\n  // When done, the payload takes ownership of the final value and all the stubs within. It may\r\n  // modify the value in preparation for delivery, and may deliver the value directly to the app\r\n  // without copying.\r\n  public static forEvaluate(stubs: RpcStub[], promises: LocatedPromise[]) {\r\n    return new RpcPayload(null, \"owned\", stubs, promises);\r\n  }\r\n\r\n  // Deep-copy the given value, including dup()ing all stubs.\r\n  //\r\n  // If `value` is a function, it should be bound to `oldParent` as its `this`.\r\n  //\r\n  // If deep-copying from a branch of some other RpcPayload, it must be provided, to make sure\r\n  // RpcTargets found within don't get duplicate stubs.\r\n  public static deepCopyFrom(\r\n      value: unknown, oldParent: object | undefined, owner: RpcPayload | null): RpcPayload {\r\n    let result = new RpcPayload(null, \"owned\", [], []);\r\n    result.value = result.deepCopy(value, oldParent, \"value\", result, /*dupStubs=*/true, owner);\r\n    return result;\r\n  }\r\n\r\n  // Private constructor; use factory functions above to construct.\r\n  private constructor(\r\n    // The payload value.\r\n    public value: unknown,\r\n\r\n    // What is the provenance of `value`?\r\n    // \"params\": It came from the app, in params to a call. We must dupe any stubs within.\r\n    // \"return\": It came from the app, returned from a call. We take ownership of all stubs within.\r\n    // \"owned\": This value belongs fully to us, either because it was deserialized from the wire\r\n    //   or because we deep-copied a value from the app.\r\n    private source: \"params\" | \"return\" | \"owned\",\r\n\r\n    // `stubs` and `promises` are filled in only if `value` belongs to us (`source` is \"owned\") and\r\n    // so can safely be delivered to the app. If `value` came from then app in the first place,\r\n    // then it cannot be delivered back to the app nor modified by us without first deep-copying\r\n    // it. `stubs` and `promises` will be computed as part of the deep-copy.\r\n\r\n    // All non-promise stubs found in `value`. Provided so that they can easily be disposed.\r\n    private stubs?: RpcStub[],\r\n\r\n    // All promises found in `value`. The locations of each promise are provided to allow\r\n    // substitutions later.\r\n    private promises?: LocatedPromise[]\r\n  ) {}\r\n\r\n  // For `source === \"return\"` payloads only, this tracks any StubHooks created around RpcTargets\r\n  // found in the payload at the time that it is serialized (or deep-copied) for return, so that we\r\n  // can make sure they are not disposed before the pipeline ends.\r\n  //\r\n  // This is initialized on first use.\r\n  private rpcTargets?: Map<RpcTarget | Function, StubHook>;\r\n\r\n  // Get the StubHook representing the given RpcTarget found inside this payload.\r\n  public getHookForRpcTarget(target: RpcTarget | Function, parent: object | undefined,\r\n                             dupStubs: boolean = true): StubHook {\r\n    if (this.source === \"params\") {\r\n      return TargetStubHook.create(target, parent);\r\n    } else if (this.source === \"return\") {\r\n      // If dupStubs is true, we want to both make sure the map contains the stub, and also return\r\n      // a dup of that stub.\r\n      //\r\n      // If dupStubs is false, then we are being called as part of ensureDeepCopy(), i.e. replacing\r\n      // ourselves with a deep copy. In this case we actually want the copy to end up owning all\r\n      // the hooks, and the map to be left empty. So what we do in this case is:\r\n      // * If the target is not in the map, we just create it, but don't populate the map.\r\n      // * If the target *is* in the map, we *remove* the hook from the map, and return it.\r\n\r\n      let hook = this.rpcTargets?.get(target);\r\n      if (hook) {\r\n        if (dupStubs) {\r\n          return hook.dup();\r\n        } else {\r\n          this.rpcTargets?.delete(target);\r\n          return hook;\r\n        }\r\n      } else {\r\n        hook = TargetStubHook.create(target, parent);\r\n        if (dupStubs) {\r\n          if (!this.rpcTargets) {\r\n            this.rpcTargets = new Map;\r\n          }\r\n          this.rpcTargets.set(target, hook);\r\n          return hook.dup();\r\n        } else {\r\n          return hook;\r\n        }\r\n      }\r\n    } else {\r\n      throw new Error(\"owned payload shouldn't contain raw RpcTargets\");\r\n    }\r\n  }\r\n\r\n  private deepCopy(\r\n      value: unknown, oldParent: object | undefined, property: string | number, parent: object,\r\n      dupStubs: boolean, owner: RpcPayload | null): unknown {\r\n    let kind = typeForRpc(value);\r\n    switch (kind) {\r\n      case \"unsupported\":\r\n        // This will throw later on when someone tries to do something with it.\r\n        return value;\r\n\r\n      case \"primitive\":\r\n      case \"bigint\":\r\n      case \"date\":\r\n      case \"bytes\":\r\n      case \"error\":\r\n      case \"undefined\":\r\n        // immutable, no need to copy\r\n        // TODO: Should errors be copied if they have own properties?\r\n        return value;\r\n\r\n      case \"array\": {\r\n        // We have to construct the new array first, then fill it in, so we can pass it as the\r\n        // parent.\r\n        let array = <Array<unknown>>value;\r\n        let len = array.length;\r\n        let result = new Array(len);\r\n        for (let i = 0; i < len; i++) {\r\n          result[i] = this.deepCopy(array[i], array, i, result, dupStubs, owner);\r\n        }\r\n        return result;\r\n      }\r\n\r\n      case \"object\": {\r\n        // Plain object. Unfortunately there's no way to pre-allocate the right shape.\r\n        let result: Record<string, unknown> = {};\r\n        let object = <Record<string, unknown>>value;\r\n        for (let i in object) {\r\n          result[i] = this.deepCopy(object[i], object, i, result, dupStubs, owner);\r\n        }\r\n        return result;\r\n      }\r\n\r\n      case \"stub\":\r\n      case \"rpc-promise\": {\r\n        let stub = <RpcStub>value;\r\n        let hook: StubHook;\r\n        if (dupStubs) {\r\n          hook = unwrapStubAndDup(stub);\r\n        } else {\r\n          hook = unwrapStubTakingOwnership(stub);\r\n        }\r\n        if (stub instanceof RpcPromise) {\r\n          let promise = new RpcPromise(hook, []);\r\n          this.promises!.push({parent, property, promise});\r\n          return promise;\r\n        } else {\r\n          let newStub = new RpcStub(hook);\r\n          this.stubs!.push(newStub);\r\n          return newStub;\r\n        }\r\n      }\r\n\r\n      case \"function\":\r\n      case \"rpc-target\": {\r\n        let target = <RpcTarget | Function>value;\r\n        let stub: RpcStub;\r\n        if (owner) {\r\n          stub = new RpcStub(owner.getHookForRpcTarget(target, oldParent, dupStubs));\r\n        } else {\r\n          stub = new RpcStub(TargetStubHook.create(target, oldParent));\r\n        }\r\n        this.stubs!.push(stub);\r\n        return stub;\r\n      }\r\n\r\n      case \"rpc-thenable\": {\r\n        let target = <RpcTarget>value;\r\n        let promise: RpcPromise;\r\n        if (owner) {\r\n          promise = new RpcPromise(owner.getHookForRpcTarget(target, oldParent, dupStubs), []);\r\n        } else {\r\n          promise = new RpcPromise(TargetStubHook.create(target, oldParent), []);\r\n        }\r\n        this.promises!.push({parent, property, promise});\r\n        return promise;\r\n      }\r\n\r\n      default:\r\n        kind satisfies never;\r\n        throw new Error(\"unreachable\");\r\n    }\r\n  }\r\n\r\n  // Ensures that if the value originally came from an unowned source, we have replaced it with a\r\n  // deep copy.\r\n  public ensureDeepCopied() {\r\n    if (this.source !== \"owned\") {\r\n      // If we came from call params, we need to dupe any stubs. Otherwise (we came from a return),\r\n      // we take ownership of all stubs.\r\n      let dupStubs = this.source === \"params\";\r\n\r\n      this.stubs = [];\r\n      this.promises = [];\r\n\r\n      // Deep-copy the value.\r\n      try {\r\n        this.value = this.deepCopy(this.value, undefined, \"value\", this, dupStubs, this);\r\n      } catch (err) {\r\n        // Roll back the change.\r\n        this.stubs = undefined;\r\n        this.promises = undefined;\r\n        throw err;\r\n      }\r\n\r\n      // We now own the value.\r\n      this.source = \"owned\";\r\n\r\n      // `rpcTargets` should have been left empty. We can throw it out.\r\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\r\n        throw new Error(\"Not all rpcTargets were accounted for in deep-copy?\");\r\n      }\r\n      this.rpcTargets = undefined;\r\n    }\r\n  }\r\n\r\n  // Resolve all promises in this payload and then assign the final value into `parent[property]`.\r\n  private deliverTo(parent: object, property: string | number, promises: Promise<any>[]): void {\r\n    this.ensureDeepCopied();\r\n\r\n    if (this.value instanceof RpcPromise) {\r\n      RpcPayload.deliverRpcPromiseTo(this.value, parent, property, promises);\r\n    } else {\r\n      (<any>parent)[property] = this.value;\r\n\r\n      for (let record of this.promises!) {\r\n        // Note that because we already did ensureDeepCopied(), replacing each promise with its\r\n        // resolution does not interfere with disposal later on -- disposal will be based on the\r\n        // `promises` list, so will still properly dispose each promise, which in turn disposes\r\n        // the promise's eventual payload.\r\n        RpcPayload.deliverRpcPromiseTo(record.promise, record.parent, record.property, promises);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static deliverRpcPromiseTo(\r\n      promise: RpcPromise, parent: object, property: string | number,\r\n      promises: Promise<unknown>[]) {\r\n    // deepCopy() should have replaced any property stubs with normal promise stubs.\r\n    let hook = unwrapStubNoProperties(promise);\r\n    if (!hook) {\r\n      throw new Error(\"property promises should have been resolved earlier\");\r\n    }\r\n\r\n    let inner = hook.pull();\r\n    if (inner instanceof RpcPayload) {\r\n      // Immediately resolved to payload.\r\n      inner.deliverTo(parent, property, promises);\r\n    } else {\r\n      // It's a promise.\r\n      promises.push(inner.then(payload => {\r\n        let subPromises: Promise<unknown>[] = [];\r\n        payload.deliverTo(parent, property, subPromises);\r\n        if (subPromises.length > 0) {\r\n          return Promise.all(subPromises);\r\n        }\r\n      }));\r\n    }\r\n  }\r\n\r\n  // Call the given function with the payload as an argument. The call is made synchronously if\r\n  // possible, in order to maintain e-order. However, if any RpcPromises exist in the payload,\r\n  // they are awaited and substituted before calling the function. The result of the call is\r\n  // wrapped into another payload.\r\n  //\r\n  // The payload is automatically disposed after the call completes. The caller should not call\r\n  // dispose().\r\n  public async deliverCall(func: Function, thisArg: object | undefined): Promise<RpcPayload> {\r\n    try {\r\n      let promises: Promise<void>[] = [];\r\n      this.deliverTo(this, \"value\", promises);\r\n\r\n      // WARNING: It is critical that if the promises list is empty, we do not await anything, so\r\n      //   that the function is called immediately and synchronously. Otherwise, we might violate\r\n      //   e-order.\r\n      if (promises.length > 0) {\r\n        await Promise.all(promises);\r\n      }\r\n\r\n      // Call the function.\r\n      let result = Function.prototype.apply.call(func, thisArg, this.value);\r\n\r\n      if (result instanceof RpcPromise) {\r\n        // Special case: If the function immediately returns RpcPromise, we don't want to await it,\r\n        // since that will actually wait for the promise. Instead we want to construct a payload\r\n        // around it directly.\r\n        return RpcPayload.fromAppReturn(result);\r\n      } else {\r\n        // In all other cases, await the result (which may or may not be a promise, but `await`\r\n        // will just pass through non-promises).\r\n        return RpcPayload.fromAppReturn(await result);\r\n      }\r\n    } finally {\r\n      this.dispose();\r\n    }\r\n  }\r\n\r\n  // Produce a promise for this payload for return to the application. Any RpcPromises in the\r\n  // payload are awaited and substituted with their results first.\r\n  //\r\n  // The returned object will have a disposer which disposes the payload. The caller should not\r\n  // separately dispose it.\r\n  public async deliverResolve(): Promise<unknown> {\r\n    try {\r\n      let promises: Promise<void>[] = [];\r\n      this.deliverTo(this, \"value\", promises);\r\n\r\n      if (promises.length > 0) {\r\n        await Promise.all(promises);\r\n      }\r\n\r\n      let result = this.value;\r\n\r\n      // Add disposer to result.\r\n      if (result instanceof Object) {\r\n        if (!(Symbol.dispose in result)) {\r\n          // We want the disposer to be non-enumerable as otherwise it gets in the way of things\r\n          // like unit tests trying to deep-compare the result to an object.\r\n          Object.defineProperty(result, Symbol.dispose, {\r\n            // NOTE: Using `this.dispose.bind(this)` here causes Playwright's build of\r\n            //   Chromium 140.0.7339.16 to fail when the object is assigned to a `using` variable,\r\n            //   with the error:\r\n            //       TypeError: Symbol(Symbol.dispose) is not a function\r\n            //   I cannot reproduce this problem in Chrome 140.0.7339.127 nor in Node or workerd,\r\n            //   so maybe it was a short-lived V8 bug or something. To be safe, though, we use\r\n            //   `() => this.dispose()`, which seems to always work.\r\n            value: () => this.dispose(),\r\n            writable: true,\r\n            enumerable: false,\r\n            configurable: true,\r\n          });\r\n        }\r\n      }\r\n\r\n      return result;\r\n    } catch (err) {\r\n      // Automatically dispose since the application will never receive the disposable...\r\n      this.dispose();\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  public dispose() {\r\n    if (this.source === \"owned\") {\r\n      // Oh good, we can just run through them.\r\n      this.stubs!.forEach(stub => stub[Symbol.dispose]());\r\n      this.promises!.forEach(promise => promise.promise[Symbol.dispose]());\r\n    } else if (this.source === \"return\") {\r\n      // Value received directly from app as a return value. We take ownership of all stubs, so we\r\n      // must recursively scan it for things to dispose.\r\n      this.disposeImpl(this.value, undefined);\r\n      if (this.rpcTargets && this.rpcTargets.size > 0) {\r\n        throw new Error(\"Not all rpcTargets were accounted for in disposeImpl()?\");\r\n      }\r\n    } else {\r\n      // this.source is \"params\". We don't own the stubs within.\r\n    }\r\n\r\n    // Make dispose() idempotent.\r\n    this.source = \"owned\";\r\n    this.stubs = [];\r\n    this.promises = [];\r\n  }\r\n\r\n  // Recursive dispose, called only when `source` is \"return\".\r\n  private disposeImpl(value: unknown, parent: object | undefined) {\r\n    let kind = typeForRpc(value);\r\n    switch (kind) {\r\n      case \"unsupported\":\r\n      case \"primitive\":\r\n      case \"bigint\":\r\n      case \"bytes\":\r\n      case \"date\":\r\n      case \"error\":\r\n      case \"undefined\":\r\n        return;\r\n\r\n      case \"array\": {\r\n        let array = <Array<unknown>>value;\r\n        let len = array.length;\r\n        for (let i = 0; i < len; i++) {\r\n          this.disposeImpl(array[i], array);\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"object\": {\r\n        let object = <Record<string, unknown>>value;\r\n        for (let i in object) {\r\n          this.disposeImpl(object[i], object);\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"stub\":\r\n      case \"rpc-promise\": {\r\n        let stub = <RpcStub>value;\r\n        let hook = unwrapStubNoProperties(stub);\r\n        if (hook) {\r\n          hook.dispose();\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"function\":\r\n      case \"rpc-target\": {\r\n        let target = <RpcTarget | Function>value;\r\n        let hook = this.rpcTargets?.get(target);\r\n        if (hook) {\r\n          // We created a hook around this target earlier. Dispose it now.\r\n          hook.dispose();\r\n          this.rpcTargets!.delete(target);\r\n        } else {\r\n          // There never was a stub pointing at this target. This could be because:\r\n          // * The call was used only for promise pipelining, so the result was never serialized,\r\n          //   so it never got added to `rpcTargets`.\r\n          // * The same RpcTarget appears in the results twice, and we already disposed the hook\r\n          //   when we saw it earlier. Note that it's intentional that we should call the disposer\r\n          //   twice if the same object appears twice.\r\n          disposeRpcTarget(target);\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"rpc-thenable\":\r\n        // Since thenables are promises, we don't own them, so we don't dispose them.\r\n        return;\r\n\r\n      default:\r\n        kind satisfies never;\r\n        return;\r\n    }\r\n  }\r\n\r\n  // Ignore unhandled rejections in all promises in this payload -- that is, all promises that\r\n  // *would* be awaited if this payload were to be delivered. See the similarly-named method of\r\n  // StubHook for explanation.\r\n  ignoreUnhandledRejections(): void {\r\n    if (this.stubs) {\r\n      // Propagate to all stubs and promises.\r\n      this.stubs.forEach(stub => {\r\n        unwrapStubOrParent(stub).ignoreUnhandledRejections();\r\n      });\r\n      this.promises!.forEach(\r\n          promise => unwrapStubOrParent(promise.promise).ignoreUnhandledRejections());\r\n    } else {\r\n      // Ugh we have to walk the tree.\r\n      this.ignoreUnhandledRejectionsImpl(this.value);\r\n    }\r\n  }\r\n\r\n  private ignoreUnhandledRejectionsImpl(value: unknown) {\r\n    let kind = typeForRpc(value);\r\n    switch (kind) {\r\n      case \"unsupported\":\r\n      case \"primitive\":\r\n      case \"bigint\":\r\n      case \"bytes\":\r\n      case \"date\":\r\n      case \"error\":\r\n      case \"undefined\":\r\n      case \"function\":\r\n      case \"rpc-target\":\r\n        return;\r\n\r\n      case \"array\": {\r\n        let array = <Array<unknown>>value;\r\n        let len = array.length;\r\n        for (let i = 0; i < len; i++) {\r\n          this.ignoreUnhandledRejectionsImpl(array[i]);\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"object\": {\r\n        let object = <Record<string, unknown>>value;\r\n        for (let i in object) {\r\n          this.ignoreUnhandledRejectionsImpl(object[i]);\r\n        }\r\n        return;\r\n      }\r\n\r\n      case \"stub\":\r\n      case \"rpc-promise\":\r\n        unwrapStubOrParent(<RpcStub>value).ignoreUnhandledRejections();\r\n        return;\r\n\r\n      case \"rpc-thenable\":\r\n        (<any>value).then((_: any) => {}, (_: any) => {});\r\n        return;\r\n\r\n      default:\r\n        kind satisfies never;\r\n        return;\r\n    }\r\n  }\r\n};\r\n\r\n// =======================================================================================\r\n// Local StubHook implementations\r\n\r\n// Result of followPath().\r\ntype FollowPathResult = {\r\n  // Path led to a regular value.\r\n\r\n  value: unknown,              // the value\r\n  parent: object | undefined,  // the immediate parent (useful as `this` if making a call)\r\n  owner: RpcPayload | null,    // RpcPayload that owns the value, if any\r\n\r\n  hook?: never,\r\n  remainingPath?: never,\r\n} | {\r\n  // Path leads into another stub, which needs to be called recursively.\r\n\r\n  hook: StubHook,               // StubHook of the inner stub.\r\n  remainingPath: PropertyPath,  // Path to pass to `hook` when recursing.\r\n\r\n  value?: never,\r\n  parent?: never,\r\n  owner?: never,\r\n};\r\n\r\nfunction followPath(value: unknown, parent: object | undefined,\r\n                    path: PropertyPath, owner: RpcPayload | null): FollowPathResult {\r\n  for (let i = 0; i < path.length; i++) {\r\n    parent = <object>value;\r\n\r\n    let part = path[i];\r\n    if (part in Object.prototype) {\r\n      // Don't allow messing with Object.prototype properties over RPC. We block these even if\r\n      // the specific object has overridden them for consistency with the deserialization code,\r\n      // which will refuse to deserialize an object containing such properties. Anyway, it's\r\n      // impossible for a normal client to even request these because accessing Object prototype\r\n      // properties on a stub will resolve to the local prototype property, not making an RPC at\r\n      // all.\r\n      value = undefined;\r\n      continue;\r\n    }\r\n\r\n    let kind = typeForRpc(value);\r\n    switch (kind) {\r\n      case \"object\":\r\n      case \"function\":\r\n        // Must be own property, NOT inherited from a prototype.\r\n        if (Object.hasOwn(<object>value, part)) {\r\n          value = (<any>value)[part];\r\n        } else {\r\n          value = undefined;\r\n        }\r\n        break;\r\n\r\n      case \"array\":\r\n        // For arrays, restrict specifically to numeric indexes, to be consistent with\r\n        // serialization, which only sends a flat list.\r\n        if (Number.isInteger(part) && <number>part >= 0) {\r\n          value = (<any>value)[part];\r\n        } else {\r\n          value = undefined;\r\n        }\r\n        break;\r\n\r\n      case \"rpc-target\":\r\n      case \"rpc-thenable\": {\r\n        // Must be prototype property, and must NOT be inherited from `Object`.\r\n        if (Object.hasOwn(<object>value, part)) {\r\n          value = undefined;\r\n        } else {\r\n          value = (<any>value)[part];\r\n        }\r\n\r\n        // Since we're descending into the RpcTarget, the rest of the path is not \"owned\" by any\r\n        // RpcPayload.\r\n        owner = null;\r\n        break;\r\n      }\r\n\r\n      case \"stub\":\r\n      case \"rpc-promise\": {\r\n        let {hook: hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\r\n        return { hook, remainingPath:\r\n            pathIfPromise ? pathIfPromise.concat(path.slice(i)) : path.slice(i) };\r\n      }\r\n\r\n      case \"primitive\":\r\n      case \"bigint\":\r\n      case \"bytes\":\r\n      case \"date\":\r\n      case \"error\":\r\n        // These have no properties that can be accessed remotely.\r\n        value = undefined;\r\n        break;\r\n\r\n      case \"undefined\":\r\n        // Intentionally produce TypeError.\r\n        value = (value as any)[part];\r\n        break;\r\n\r\n      case \"unsupported\": {\r\n        if (i === 0) {\r\n          throw new TypeError(`RPC stub points at a non-serializable type.`);\r\n        } else {\r\n          let prefix = path.slice(0, i).join(\".\");\r\n          let remainder = path.slice(0, i).join(\".\");\r\n          throw new TypeError(\r\n              `'${prefix}' is not a serializable type, so property ${remainder} cannot ` +\r\n              `be accessed.`);\r\n        }\r\n      }\r\n\r\n      default:\r\n        kind satisfies never;\r\n        throw new TypeError(\"unreachable\");\r\n    }\r\n  }\r\n\r\n  // If we reached a promise, we actually want the caller to forward to the promise, not return\r\n  // the promise itself.\r\n  if (value instanceof RpcPromise) {\r\n    let {hook: hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\r\n    return { hook, remainingPath: pathIfPromise || [] };\r\n  }\r\n\r\n  // We don't validate the final value itself because we don't know the intended use yet. If it's\r\n  // for a call, any callable is valid. If it's for get(), then any serializable value is valid.\r\n  return {\r\n    value,\r\n    parent,\r\n    owner,\r\n  };\r\n}\r\n\r\n// Shared base class for PayloadStubHook and TargetStubHook.\r\nabstract class ValueStubHook extends StubHook {\r\n  protected abstract getValue(): {value: unknown, owner: RpcPayload | null};\r\n\r\n  call(path: PropertyPath, args: RpcPayload): StubHook {\r\n    try {\r\n      let {value, owner} = this.getValue();\r\n      let followResult = followPath(value, undefined, path, owner);\r\n\r\n      if (followResult.hook) {\r\n        return followResult.hook.call(followResult.remainingPath, args);\r\n      }\r\n\r\n      // It's a local function.\r\n      if (typeof followResult.value != \"function\") {\r\n        throw new TypeError(`'${path.join('.')}' is not a function.`);\r\n      }\r\n      let promise = args.deliverCall(followResult.value, followResult.parent);\r\n      return new PromiseStubHook(promise.then(payload => {\r\n        return new PayloadStubHook(payload);\r\n      }));\r\n    } catch (err) {\r\n      return new ErrorStubHook(err);\r\n    }\r\n  }\r\n\r\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\r\n    try {\r\n      let followResult: FollowPathResult;\r\n      try {\r\n        let {value, owner} = this.getValue();\r\n        followResult = followPath(value, undefined, path, owner);;\r\n      } catch (err) {\r\n        // Oops, we need to dispose the captures of which we took ownership.\r\n        for (let cap of captures) {\r\n          cap.dispose();\r\n        }\r\n        throw err;\r\n      }\r\n\r\n      if (followResult.hook) {\r\n        return followResult.hook.map(followResult.remainingPath, captures, instructions);\r\n      }\r\n\r\n      return mapImpl.applyMap(\r\n          followResult.value, followResult.parent, followResult.owner, captures, instructions);\r\n    } catch (err) {\r\n      return new ErrorStubHook(err);\r\n    }\r\n  }\r\n\r\n  get(path: PropertyPath): StubHook {\r\n    try {\r\n      let {value, owner} = this.getValue();\r\n\r\n      if (path.length === 0 && owner === null) {\r\n        // The only way this happens is if someone sends \"pipeline\" and references a\r\n        // TargetStubHook, but they shouldn't do that, because TargetStubHook never backs a\r\n        // promise, and a non-promise cannot be converted to a promise.\r\n        // TODO: Is this still correct for rpc-thenable?\r\n        throw new Error(\"Can't dup an RpcTarget stub as a promise.\");\r\n      }\r\n\r\n      let followResult = followPath(value, undefined, path, owner);\r\n\r\n      if (followResult.hook) {\r\n        return followResult.hook.get(followResult.remainingPath);\r\n      }\r\n\r\n      // Note that if `followResult.owner` is null, then we've descended into the contents of an\r\n      // RpcTarget. In that case, if this deep copy discovers an RpcTarget embedded in the result,\r\n      // it will create a new stub for it. If that RpcTarget has a disposer, it'll be disposed when\r\n      // that stub is disposed. If the same RpcTarget is returned in *another* get(), it create\r\n      // *another* stub, which calls the disposer *another* time. This can be quite weird -- the\r\n      // disposer may be called any number of times, including zero if the property is never read\r\n      // at all. Unfortunately, that's just the way it is. The application can avoid this problem by\r\n      // wrapping the RpcTarget in an RpcStub itself, proactively, and using that as the property --\r\n      // then, each time the property is get()ed, a dup() of that stub is returned.\r\n      return new PayloadStubHook(RpcPayload.deepCopyFrom(\r\n          followResult.value, followResult.parent, followResult.owner));\r\n    } catch (err) {\r\n      return new ErrorStubHook(err);\r\n    }\r\n  }\r\n}\r\n\r\n// StubHook wrapping an RpcPayload in local memory.\r\n//\r\n// This is used for:\r\n// - Resolution of a promise.\r\n//   - Initially on the server side, where it can be pull()ed and used in pipelining.\r\n//   - On the client side, after pull() has transmitted the payload.\r\n// - Implementing RpcTargets, on the server side.\r\n//   - Since the payload's root is an RpcTarget, pull()ing it will just duplicate the stub.\r\nexport class PayloadStubHook extends ValueStubHook {\r\n  constructor(payload: RpcPayload) {\r\n    super();\r\n    this.payload = payload;\r\n  }\r\n\r\n  private payload?: RpcPayload;  // cleared when disposed\r\n\r\n  private getPayload(): RpcPayload {\r\n    if (this.payload) {\r\n      return this.payload;\r\n    } else {\r\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\r\n    }\r\n  }\r\n\r\n  protected getValue() {\r\n    let payload = this.getPayload();\r\n    return {value: payload.value, owner: payload};\r\n  }\r\n\r\n  dup(): StubHook {\r\n    // Although dup() is documented as not copying the payload, what this really means is that\r\n    // you aren't expected to be able to pull() from a dup()ed hook if it is remote. However,\r\n    // PayloadStubHook already has the value locally, and there's nothing we can do except clone\r\n    // it here.\r\n    //\r\n    // TODO: Should we prohibit pull()ing from the clone? The fact that it'll be wrapped as\r\n    //   RpcStub instead of RpcPromise should already prevent this...\r\n    let thisPayload = this.getPayload();\r\n    return new PayloadStubHook(RpcPayload.deepCopyFrom(\r\n        thisPayload.value, undefined, thisPayload));\r\n  }\r\n\r\n  pull(): RpcPayload | Promise<RpcPayload> {\r\n    // Reminder: pull() intentionally returns the hook's own payload and not a clone. The caller\r\n    // only needs to dispose one of the hook or the payload. It is the caller's responsibility\r\n    // to not dispose the payload if they intend to keep the hook around.\r\n    return this.getPayload();\r\n  }\r\n\r\n  ignoreUnhandledRejections(): void {\r\n    if (this.payload) {\r\n      this.payload.ignoreUnhandledRejections();\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.payload) {\r\n      this.payload.dispose();\r\n      this.payload = undefined;\r\n    }\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    if (this.payload) {\r\n      if (this.payload.value instanceof RpcStub) {\r\n        // Payload is a single stub, we should forward onRpcBroken to it.\r\n        // TODO: Consider prohibiting PayloadStubHook created around a single stub; should always\r\n        //   use the underlying stub's hook instead?\r\n        this.payload.value.onRpcBroken(callback);\r\n      }\r\n\r\n      // TODO: Should native stubs be able to implement onRpcBroken?\r\n    }\r\n  }\r\n}\r\n\r\nfunction disposeRpcTarget(target: RpcTarget | Function) {\r\n  if (Symbol.dispose in target) {\r\n    try {\r\n      ((<Disposable><any>target)[Symbol.dispose])();\r\n    } catch (err) {\r\n      // We don't actually want to throw from dispose() as this will create trouble for\r\n      // the RPC state machine. Instead, treat the application's error as an unhandled\r\n      // rejection.\r\n      Promise.reject(err);\r\n    }\r\n  }\r\n}\r\n\r\n// Many TargetStubHooks could point at the same RpcTarget. We store a refcount in a separate\r\n// object that they all share.\r\n//\r\n// We can't store the refcount on the RpcTarget itself because if the application chooses to pass\r\n// the same RpcTarget into the RPC system multiple times, we need to call this disposer multiple\r\n// times for consistency.\r\ntype BoxedRefcount = { count: number };\r\n\r\n// StubHook which wraps an RpcTarget. This has similarities to PayloadStubHook (especially when\r\n// the root of the payload happens to be an RpcTarget), but there can only be one RpcPayload\r\n// pointing at an RpcTarget whereas there can be several TargetStubHooks pointing at it. Also,\r\n// TargetStubHook cannot be pull()ed, because it always backs an RpcStub, not an RpcPromise.\r\nclass TargetStubHook extends ValueStubHook {\r\n  // Constructs a TargetStubHook that is not duplicated from an existing hook.\r\n  //\r\n  // If `value` is a function, `parent` is bound as its \"this\".\r\n  static create(value: RpcTarget | Function, parent: object | undefined) {\r\n    if (typeof value !== \"function\") {\r\n      // If the target isn't callable, we don't need to pass a `this` to it, so drop `parent`.\r\n      // NOTE: `typeof value === \"function\"` checks if the value is callable. This technically\r\n      //   works even for `RpcTarget` implementations that are callable, not just plain functions.\r\n      parent = undefined;\r\n    }\r\n    return new TargetStubHook(value, parent);\r\n  }\r\n\r\n  private constructor(target: RpcTarget | Function,\r\n                      parent?: object | undefined,\r\n                      dupFrom?: TargetStubHook) {\r\n    super();\r\n    this.target = target;\r\n    this.parent = parent;\r\n    if (dupFrom) {\r\n      if (dupFrom.refcount) {\r\n        this.refcount = dupFrom.refcount;\r\n        ++this.refcount.count;\r\n      }\r\n    } else if (Symbol.dispose in target) {\r\n      // Disposer present, so we need to refcount.\r\n      this.refcount = {count: 1};\r\n    }\r\n  }\r\n\r\n  private target?: RpcTarget | Function;  // cleared when disposed\r\n  private parent?: object | undefined;  // `this` parameter when calling `target`\r\n  private refcount?: BoxedRefcount;  // undefined if not needed (because target has no disposer)\r\n\r\n  private getTarget(): RpcTarget | Function {\r\n    if (this.target) {\r\n      return this.target;\r\n    } else {\r\n      throw new Error(\"Attempted to use an RPC StubHook after it was disposed.\");\r\n    }\r\n  }\r\n\r\n  protected getValue() {\r\n    return {value: this.getTarget(), owner: null};\r\n  }\r\n\r\n  dup(): StubHook {\r\n    return new TargetStubHook(this.getTarget(), this.parent, this);\r\n  }\r\n\r\n  pull(): RpcPayload | Promise<RpcPayload> {\r\n    let target = this.getTarget();\r\n    if (\"then\" in target) {\r\n      // If the target is itself thenable, we allow it to be treated as a promise. This is used\r\n      // in particular to support wrapping a workerd-native RpcPromise or RpcProperty.\r\n      return Promise.resolve(target).then(resolution => {\r\n        return RpcPayload.fromAppReturn(resolution);\r\n      });\r\n    } else {\r\n      // This shouldn't be called since RpcTarget always becomes RpcStub, not RpcPromise, and you\r\n      // can only pull a promise.\r\n      return Promise.reject(new Error(\"Tried to resolve a non-promise stub.\"));\r\n    }\r\n  }\r\n\r\n  ignoreUnhandledRejections(): void {\r\n    // Nothing to do.\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.target) {\r\n      if (this.refcount) {\r\n        if (--this.refcount.count == 0) {\r\n          disposeRpcTarget(this.target);\r\n        }\r\n      }\r\n\r\n      this.target = undefined;\r\n    }\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    // TODO: Should RpcTargets be able to implement onRpcBroken?\r\n  }\r\n}\r\n\r\n// StubHook derived from a Promise for some other StubHook. Waits for the promise and then\r\n// forward calls, being careful to honor e-order.\r\nclass PromiseStubHook extends StubHook {\r\n  private promise: Promise<StubHook>;\r\n  private resolution: StubHook | undefined;\r\n\r\n  constructor(promise: Promise<StubHook>) {\r\n    super();\r\n\r\n    this.promise = promise.then(res => { this.resolution = res; return res; });\r\n  }\r\n\r\n  call(path: PropertyPath, args: RpcPayload): StubHook {\r\n    // Note: We can't use `resolution` even if it's available because it could technically break\r\n    //   e-order: A call() that arrives just after the resolution could be delivered faster than\r\n    //   a call() that arrives just before. Keeping the promise around and always waiting on it\r\n    //   avoids the problem.\r\n    // TODO: Is there a way around this?\r\n\r\n    // Once call() returns (synchronously), we can no longer touch the original args. Since we\r\n    // can't serialize them yet, we have to deep-copy them now.\r\n    args.ensureDeepCopied();\r\n\r\n    return new PromiseStubHook(this.promise.then(hook => hook.call(path, args)));\r\n  }\r\n\r\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\r\n    return new PromiseStubHook(this.promise.then(\r\n        hook => hook.map(path, captures, instructions),\r\n        err => {\r\n          for (let cap of captures) {\r\n            cap.dispose();\r\n          }\r\n          throw err;\r\n        }));\r\n  }\r\n\r\n  get(path: PropertyPath): StubHook {\r\n    // Note: e-order matters for get(), just like call(), in case the property has a getter.\r\n    return new PromiseStubHook(this.promise.then(hook => hook.get(path)));\r\n  }\r\n\r\n  dup(): StubHook {\r\n    if (this.resolution) {\r\n      return this.resolution.dup();\r\n    } else {\r\n      return new PromiseStubHook(this.promise.then(hook => hook.dup()));\r\n    }\r\n  }\r\n\r\n  pull(): RpcPayload | Promise<RpcPayload> {\r\n    // Luckily, resolutions are not subject to e-order, so it's safe to use `this.resolution`\r\n    // here. In fact, it is required to maintain e-order elsewhere: If this promise is being used\r\n    // as the input to some other local call (via promise pipelining), we need to make sure that\r\n    // other call is not delayed at all when this promise is already resolved.\r\n    if (this.resolution) {\r\n      return this.resolution.pull();\r\n    } else {\r\n      return this.promise.then(hook => hook.pull());\r\n    }\r\n  }\r\n\r\n  ignoreUnhandledRejections(): void {\r\n    if (this.resolution) {\r\n      this.resolution.ignoreUnhandledRejections();\r\n    } else {\r\n      this.promise.then(res => {\r\n        res.ignoreUnhandledRejections();\r\n      }, err => {\r\n        // Ignore the error!\r\n      });\r\n    }\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.resolution) {\r\n      this.resolution.dispose();\r\n    } else {\r\n      this.promise.then(hook => {\r\n        hook.dispose();\r\n      }, err => {\r\n        // nothing to dispose\r\n      });\r\n    }\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    if (this.resolution) {\r\n      this.resolution.onBroken(callback);\r\n    } else {\r\n      this.promise.then(hook => {\r\n        hook.onBroken(callback);\r\n      }, callback);\r\n    }\r\n  }\r\n}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { StubHook, RpcPayload, typeForRpc, RpcStub, RpcPromise, LocatedPromise, RpcTarget, PropertyPath, unwrapStubAndPath } from \"./core.js\";\r\n\r\nexport type ImportId = number;\r\nexport type ExportId = number;\r\n\r\n// =======================================================================================\r\n\r\nexport interface Exporter {\r\n  exportStub(hook: StubHook): ExportId;\r\n  exportPromise(hook: StubHook): ExportId;\r\n  getImport(hook: StubHook): ImportId | undefined;\r\n\r\n  // If a serialization error occurs after having exported some capabilities, this will be called\r\n  // to roll back the exports.\r\n  unexport(ids: Array<ExportId>): void;\r\n\r\n  onSendError(error: Error): Error | void;\r\n}\r\n\r\nclass NullExporter implements Exporter {\r\n  exportStub(stub: StubHook): never {\r\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\r\n  }\r\n  exportPromise(stub: StubHook): never {\r\n    throw new Error(\"Cannot serialize RPC stubs without an RPC session.\");\r\n  }\r\n  getImport(hook: StubHook): ImportId | undefined {\r\n    return undefined;\r\n  }\r\n  unexport(ids: Array<ExportId>): void {}\r\n\r\n  onSendError(error: Error): Error | void {}\r\n}\r\n\r\nconst NULL_EXPORTER = new NullExporter();\r\n\r\n// Maps error name to error class for deserialization.\r\nconst ERROR_TYPES: Record<string, any> = {\r\n  Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError,\r\n  // TODO: DOMError? Others?\r\n};\r\n\r\n// Polyfill type for UInt8Array.toBase64(), which has started landing in JS runtimes but is not\r\n// supported everywhere just yet.\r\ninterface Uint8Array {\r\n  toBase64?(options?: {\r\n    alphabet?: \"base64\" | \"base64url\",\r\n    omitPadding?: boolean\r\n  }): string;\r\n};\r\n\r\ninterface FromBase64 {\r\n  fromBase64?(text: string, options?: {\r\n    alphabet?: \"base64\" | \"base64url\",\r\n    lastChunkHandling?: \"loose\" | \"strict\" | \"stop-before-partial\"\r\n  }): Uint8Array;\r\n}\r\n\r\n// Converts fully-hydrated messages into object trees that are JSON-serializable for sending over\r\n// the wire. This is used to implement serialization -- but it doesn't take the last step of\r\n// actually converting to a string. (The name is meant to be the opposite of \"Evaluator\", which\r\n// implements the opposite direction.)\r\nexport class Devaluator {\r\n  private constructor(private exporter: Exporter, private source: RpcPayload | undefined) {}\r\n\r\n  // Devaluate the given value.\r\n  // * value: The value to devaluate.\r\n  // * parent: The value's parent object, which would be used as `this` if the value were called\r\n  //     as a function.\r\n  // * exporter: Callbacks to the RPC session for exporting capabilities found in this message.\r\n  // * source: The RpcPayload which contains the value, and therefore owns stubs within.\r\n  //\r\n  // Returns: The devaluated value, ready to be JSON-serialized.\r\n  public static devaluate(\r\n      value: unknown, parent?: object, exporter: Exporter = NULL_EXPORTER, source?: RpcPayload)\r\n      : unknown {\r\n    let devaluator = new Devaluator(exporter, source);\r\n    try {\r\n      return devaluator.devaluateImpl(value, parent, 0);\r\n    } catch (err) {\r\n      if (devaluator.exports) {\r\n        try {\r\n          exporter.unexport(devaluator.exports);\r\n        } catch (err) {\r\n          // probably a side effect of the original error, ignore it\r\n        }\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  private exports?: Array<ExportId>;\r\n\r\n  private devaluateImpl(value: unknown, parent: object | undefined, depth: number): unknown {\r\n    if (depth >= 64) {\r\n      throw new Error(\r\n          \"Serialization exceeded maximum allowed depth. (Does the message contain cycles?)\");\r\n    }\r\n\r\n    let kind = typeForRpc(value);\r\n    switch (kind) {\r\n      case \"unsupported\": {\r\n        let msg;\r\n        try {\r\n          msg = `Cannot serialize value: ${value}`;\r\n        } catch (err) {\r\n          msg = \"Cannot serialize value: (couldn't stringify value)\";\r\n        }\r\n        throw new TypeError(msg);\r\n      }\r\n\r\n      case \"primitive\":\r\n        // Supported directly by JSON.\r\n        return value;\r\n\r\n      case \"object\": {\r\n        let object = <Record<string, unknown>>value;\r\n        let result: Record<string, unknown> = {};\r\n        for (let key in object) {\r\n          result[key] = this.devaluateImpl(object[key], object, depth + 1);\r\n        }\r\n        return result;\r\n      }\r\n\r\n      case \"array\": {\r\n        let array = <Array<unknown>>value;\r\n        let len = array.length;\r\n        let result = new Array(len);\r\n        for (let i = 0; i < len; i++) {\r\n          result[i] = this.devaluateImpl(array[i], array, depth + 1);\r\n        }\r\n        // Wrap literal arrays in an outer one-element array, to \"escape\" them.\r\n        return [result];\r\n      }\r\n\r\n      case \"bigint\":\r\n        return [\"bigint\", (<bigint>value).toString()];\r\n\r\n      case \"date\":\r\n        return [\"date\", (<Date>value).getTime()];\r\n\r\n      case \"bytes\": {\r\n        let bytes = value as Uint8Array;\r\n        if (bytes.toBase64) {\r\n          return [\"bytes\", bytes.toBase64({omitPadding: true})];\r\n        } else {\r\n          return [\"bytes\",\r\n              btoa(String.fromCharCode.apply(null, bytes as number[]).replace(/=*$/, \"\"))];\r\n        }\r\n      }\r\n\r\n      case \"error\": {\r\n        let e = <Error>value;\r\n\r\n        // TODO:\r\n        // - Determine type by checking prototype rather than `name`, which can be overridden?\r\n        // - Serialize cause / suppressed error / etc.\r\n        // - Serialize added properties.\r\n\r\n        let rewritten = this.exporter.onSendError(e);\r\n        if (rewritten) {\r\n          e = rewritten;\r\n        }\r\n\r\n        let result = [\"error\", e.name, e.message];\r\n        if (rewritten && rewritten.stack) {\r\n          result.push(rewritten.stack);\r\n        }\r\n        return result;\r\n      }\r\n\r\n      case \"undefined\":\r\n        return [\"undefined\"];\r\n\r\n      case \"stub\":\r\n      case \"rpc-promise\": {\r\n        if (!this.source) {\r\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\r\n        }\r\n\r\n        let {hook, pathIfPromise} = unwrapStubAndPath(<RpcStub>value);\r\n        let importId = this.exporter.getImport(hook);\r\n        if (importId !== undefined) {\r\n          if (pathIfPromise) {\r\n            // It's a promise pointing back to the peer, so we are doing pipelining here.\r\n            if (pathIfPromise.length > 0) {\r\n              return [\"pipeline\", importId, pathIfPromise];\r\n            } else {\r\n              return [\"pipeline\", importId];\r\n            }\r\n          } else {\r\n            return [\"import\", importId];\r\n          }\r\n        }\r\n\r\n        if (pathIfPromise) {\r\n          hook = hook.get(pathIfPromise);\r\n        } else {\r\n          hook = hook.dup();\r\n        }\r\n\r\n        return this.devaluateHook(pathIfPromise ? \"promise\" : \"export\", hook);\r\n      }\r\n\r\n      case \"function\":\r\n      case \"rpc-target\": {\r\n        if (!this.source) {\r\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\r\n        }\r\n\r\n        let hook = this.source.getHookForRpcTarget(<RpcTarget|Function>value, parent);\r\n        return this.devaluateHook(\"export\", hook);\r\n      }\r\n\r\n      case \"rpc-thenable\": {\r\n        if (!this.source) {\r\n          throw new Error(\"Can't serialize RPC stubs in this context.\");\r\n        }\r\n\r\n        let hook = this.source.getHookForRpcTarget(<RpcTarget>value, parent);\r\n        return this.devaluateHook(\"promise\", hook);\r\n      }\r\n\r\n      default:\r\n        kind satisfies never;\r\n        throw new Error(\"unreachable\");\r\n    }\r\n  }\r\n\r\n  private devaluateHook(type: \"export\" | \"promise\", hook: StubHook): unknown {\r\n    if (!this.exports) this.exports = [];\r\n    let exportId = type === \"promise\" ? this.exporter.exportPromise(hook)\r\n                                      : this.exporter.exportStub(hook);\r\n    this.exports.push(exportId);\r\n    return [type, exportId];\r\n  }\r\n}\r\n\r\n/**\r\n * Serialize a value, using Cap'n Web's underlying serialization. This won't be able to serialize\r\n * RPC stubs, but it will support basic data types.\r\n */\r\nexport function serialize(value: unknown): string {\r\n  return JSON.stringify(Devaluator.devaluate(value));\r\n}\r\n\r\n// =======================================================================================\r\n\r\nexport interface Importer {\r\n  importStub(idx: ImportId): StubHook;\r\n  importPromise(idx: ImportId): StubHook;\r\n  getExport(idx: ExportId): StubHook | undefined;\r\n}\r\n\r\nclass NullImporter implements Importer {\r\n  importStub(idx: ImportId): never {\r\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\r\n  }\r\n  importPromise(idx: ImportId): never {\r\n    throw new Error(\"Cannot deserialize RPC stubs without an RPC session.\");\r\n  }\r\n  getExport(idx: ExportId): StubHook | undefined {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nconst NULL_IMPORTER = new NullImporter();\r\n\r\n// Takes object trees parse from JSON and converts them into fully-hydrated JavaScript objects for\r\n// delivery to the app. This is used to implement deserialization, except that it doesn't actually\r\n// start from a raw string.\r\nexport class Evaluator {\r\n  constructor(private importer: Importer) {}\r\n\r\n  private stubs: RpcStub[] = [];\r\n  private promises: LocatedPromise[] = [];\r\n\r\n  public evaluate(value: unknown): RpcPayload {\r\n    let payload = RpcPayload.forEvaluate(this.stubs, this.promises);\r\n    try {\r\n      payload.value = this.evaluateImpl(value, payload, \"value\");\r\n      return payload;\r\n    } catch (err) {\r\n      payload.dispose();\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Evaluate the value without destroying it.\r\n  public evaluateCopy(value: unknown): RpcPayload {\r\n    return this.evaluate(structuredClone(value));\r\n  }\r\n\r\n  private evaluateImpl(value: unknown, parent: object, property: string | number): unknown {\r\n    if (value instanceof Array) {\r\n      if (value.length == 1 && value[0] instanceof Array) {\r\n        // Escaped array. Evaluate the contents.\r\n        let result = value[0];\r\n        for (let i = 0; i < result.length; i++) {\r\n          result[i] = this.evaluateImpl(result[i], result, i);\r\n        }\r\n        return result;\r\n      } else switch (value[0]) {\r\n        case \"bigint\":\r\n          if (typeof value[1] == \"string\") {\r\n            return BigInt(value[1]);\r\n          }\r\n          break;\r\n        case \"date\":\r\n          if (typeof value[1] == \"number\") {\r\n            return new Date(value[1]);\r\n          }\r\n          break;\r\n        case \"bytes\": {\r\n          let b64 = Uint8Array as FromBase64;\r\n          if (typeof value[1] == \"string\") {\r\n            if (b64.fromBase64) {\r\n              return b64.fromBase64(value[1]);\r\n            } else {\r\n              let bs = atob(value[1]);\r\n              let len = bs.length;\r\n              let bytes = new Uint8Array(len);\r\n              for (let i = 0; i < len; i++) {\r\n                bytes[i] = bs.charCodeAt(i);\r\n              }\r\n              return bytes;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case \"error\":\r\n          if (value.length >= 3 && typeof value[1] === \"string\" && typeof value[2] === \"string\") {\r\n            let cls = ERROR_TYPES[value[1]] || Error;\r\n            let result = new cls(value[2]);\r\n            if (typeof value[3] === \"string\") {\r\n              result.stack = value[3];\r\n            }\r\n            return result;\r\n          }\r\n          break;\r\n        case \"undefined\":\r\n          if (value.length === 1) {\r\n            return undefined;\r\n          }\r\n          break;\r\n\r\n        case \"import\":\r\n        case \"pipeline\": {\r\n          // It's an \"import\" from the perspective of the sender, so it's an export from our\r\n          // side. In other words, the sender is passing our own object back to us.\r\n\r\n          if (value.length < 2 || value.length > 4) {\r\n            break;   // report error below\r\n          }\r\n\r\n          // First parameter is import ID (from the sender's perspective, so export ID from\r\n          // ours).\r\n          if (typeof value[1] != \"number\") {\r\n            break;   // report error below\r\n          }\r\n\r\n          let hook = this.importer.getExport(value[1]);\r\n          if (!hook) {\r\n            throw new Error(`no such entry on exports table: ${value[1]}`);\r\n          }\r\n\r\n          let isPromise = value[0] == \"pipeline\";\r\n\r\n          let addStub = (hook: StubHook) => {\r\n            if (isPromise) {\r\n              let promise = new RpcPromise(hook, []);\r\n              this.promises.push({promise, parent, property});\r\n              return promise;\r\n            } else {\r\n              let stub = new RpcPromise(hook, []);\r\n              this.stubs.push(stub);\r\n              return stub;\r\n            }\r\n          };\r\n\r\n          if (value.length == 2) {\r\n            // Just referencing the export itself.\r\n            if (isPromise) {\r\n              // We need to use hook.get([]) to make sure we get a promise hook.\r\n              return addStub(hook.get([]));\r\n            } else {\r\n              // dup() returns a stub hook.\r\n              return addStub(hook.dup());\r\n            }\r\n          }\r\n\r\n          // Second parameter, if given, is a property path.\r\n          let path = value[2];\r\n          if (!(path instanceof Array)) {\r\n            break;  // report error below\r\n          }\r\n          if (!path.every(\r\n              part => { return typeof part == \"string\" || typeof part == \"number\"; })) {\r\n            break;  // report error below\r\n          }\r\n\r\n          if (value.length == 3) {\r\n            // Just referencing the path, not a call.\r\n            return addStub(hook.get(path));\r\n          }\r\n\r\n          // Third parameter, if given, is call arguments. The sender has identified a function\r\n          // and wants us to call it.\r\n          //\r\n          // Usually this is used with \"pipeline\", in which case we evaluate to an\r\n          // RpcPromise. However, this can be used with \"import\", in which case the caller is\r\n          // asking that the result be coerced to RpcStub. This distinction matters if the\r\n          // result of this evaluation is to be passed as arguments to another call -- promises\r\n          // must be resolved in advance, but stubs can be passed immediately.\r\n          let args = value[3];\r\n          if (!(args instanceof Array)) {\r\n            break;  // report error below\r\n          }\r\n\r\n          // We need a new evaluator for the args, to build a separate payload.\r\n          let subEval = new Evaluator(this.importer);\r\n          args = subEval.evaluate([args]);\r\n\r\n          return addStub(hook.call(path, args));\r\n        }\r\n\r\n        case \"remap\": {\r\n          if (value.length !== 5 ||\r\n              typeof value[1] !== \"number\" ||\r\n              !(value[2] instanceof Array) ||\r\n              !(value[3] instanceof Array) ||\r\n              !(value[4] instanceof Array)) {\r\n            break;   // report error below\r\n          }\r\n\r\n          let hook = this.importer.getExport(value[1]);\r\n          if (!hook) {\r\n            throw new Error(`no such entry on exports table: ${value[1]}`);\r\n          }\r\n\r\n          let path = value[2];\r\n          if (!path.every(\r\n              part => { return typeof part == \"string\" || typeof part == \"number\"; })) {\r\n            break;  // report error below\r\n          }\r\n\r\n          let captures: StubHook[] = value[3].map(cap => {\r\n            if (!(cap instanceof Array) ||\r\n                cap.length !== 2 ||\r\n                (cap[0] !== \"import\" && cap[0] !== \"export\") ||\r\n                typeof cap[1] !== \"number\") {\r\n              throw new TypeError(`unknown map capture: ${JSON.stringify(cap)}`);\r\n            }\r\n\r\n            if (cap[0] === \"export\") {\r\n              return this.importer.importStub(cap[1]);\r\n            } else {\r\n              let exp = this.importer.getExport(cap[1]);\r\n              if (!exp) {\r\n                throw new Error(`no such entry on exports table: ${cap[1]}`);\r\n              }\r\n              return exp.dup();\r\n            }\r\n          });\r\n\r\n          let instructions = value[4];\r\n\r\n          let resultHook = hook.map(path, captures, instructions);\r\n\r\n          let promise = new RpcPromise(resultHook, []);\r\n          this.promises.push({promise, parent, property});\r\n          return promise;\r\n        }\r\n\r\n        case \"export\":\r\n        case \"promise\":\r\n          // It's an \"export\" from the perspective of the sender, i.e. they sent us a new object\r\n          // which we want to import.\r\n          //\r\n          // \"promise\" is same as \"export\" but should not be delivered to the application. If any\r\n          // promises appear in a value, they must be resolved and substituted with their results\r\n          // before delivery. Note that if the value being evaluated appeared in call params, or\r\n          // appeared in a resolve message for a promise that is being pulled, then the new promise\r\n          // is automatically also being pulled, otherwise it is not.\r\n          if (typeof value[1] == \"number\") {\r\n            if (value[0] == \"promise\") {\r\n              let hook = this.importer.importPromise(value[1]);\r\n              let promise = new RpcPromise(hook, []);\r\n              this.promises.push({parent, property, promise});\r\n              return promise;\r\n            } else {\r\n              let hook = this.importer.importStub(value[1]);\r\n              let stub = new RpcStub(hook);\r\n              this.stubs.push(stub);\r\n              return stub;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n      throw new TypeError(`unknown special value: ${JSON.stringify(value)}`);\r\n    } else if (value instanceof Object) {\r\n      let result = <Record<string, unknown>>value;\r\n      for (let key in result) {\r\n        if (key in Object.prototype || key === \"toJSON\") {\r\n          // Out of an abundance of caution, we will ignore properties that override properties\r\n          // of Object.prototype. It's especially important that we don't allow `__proto__` as it\r\n          // may lead to prototype pollution. We also would rather not allow, e.g., `toString()`,\r\n          // as overriding this could lead to various mischief.\r\n          //\r\n          // We also block `toJSON()` for similar reasons -- even though Object.prototype doesn't\r\n          // actually define it, `JSON.stringify()` treats it specially and we don't want someone\r\n          // snooping on JSON calls.\r\n          //\r\n          // We do still evaluate the inner value so that we can properly release any stubs.\r\n          this.evaluateImpl(result[key], result, key);\r\n          delete result[key];\r\n        } else {\r\n          result[key] = this.evaluateImpl(result[key], result, key);\r\n        }\r\n      }\r\n      return result;\r\n    } else {\r\n      // Other JSON types just pass through.\r\n      return value;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Deserialize a value serialized using serialize().\r\n */\r\nexport function deserialize(value: string): unknown {\r\n  let payload = new Evaluator(NULL_IMPORTER).evaluate(JSON.parse(value));\r\n  payload.dispose();  // should be no-op but just in case\r\n  return payload.value;\r\n}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { StubHook, RpcPayload, RpcStub, PropertyPath, PayloadStubHook, ErrorStubHook, RpcTarget, unwrapStubAndPath } from \"./core.js\";\r\nimport { Devaluator, Evaluator, ExportId, ImportId, Exporter, Importer, serialize } from \"./serialize.js\";\r\n\r\n/**\r\n * Interface for an RPC transport, which is a simple bidirectional message stream. Implement this\r\n * interface if the built-in transports (e.g. for HTTP batch and WebSocket) don't meet your needs.\r\n */\r\nexport interface RpcTransport {\r\n  /**\r\n   * Sends a message to the other end.\r\n   */\r\n  send(message: string): Promise<void>;\r\n\r\n  /**\r\n   * Receives a message sent by the other end.\r\n   *\r\n   * If and when the transport becomes disconnected, this will reject. The thrown error will be\r\n   * propagated to all outstanding calls and future calls on any stubs associated with the session.\r\n   * If there are no outstanding calls (and none are made in the future), then the error does not\r\n   * propagate anywhere -- this is considered a \"clean\" shutdown.\r\n   */\r\n  receive(): Promise<string>;\r\n\r\n  /**\r\n   * Indicates that the RPC system has suffered an error that prevents the session from continuing.\r\n   * The transport should ideally try to send any queued messages if it can, and then close the\r\n   * connection. (It's not strictly necessary to deliver queued messages, but the last message sent\r\n   * before abort() is called is often an \"abort\" message, which communicates the error to the\r\n   * peer, so if that is dropped, the peer may have less information about what happened.)\r\n   */\r\n  abort?(reason: any): void;\r\n}\r\n\r\n// Entry on the exports table.\r\ntype ExportTableEntry = {\r\n  hook: StubHook,\r\n  refcount: number,\r\n  pull?: Promise<void>\r\n};\r\n\r\n// Entry on the imports table.\r\nclass ImportTableEntry {\r\n  constructor(public session: RpcSessionImpl, public importId: number, pulling: boolean) {\r\n    if (pulling) {\r\n      this.activePull = Promise.withResolvers<void>();\r\n    }\r\n  }\r\n\r\n  public localRefcount: number = 0;\r\n  public remoteRefcount: number = 1;\r\n\r\n  private activePull?: PromiseWithResolvers<void>;\r\n  public resolution?: StubHook;\r\n\r\n  // List of integer indexes into session.onBrokenCallbacks which are callbacks registered on\r\n  // this import. Initialized on first use (so `undefined` is the same as an empty list).\r\n  private onBrokenRegistrations?: number[];\r\n\r\n  resolve(resolution: StubHook) {\r\n    // TODO: Need embargo handling here? PayloadStubHook needs to be wrapped in a\r\n    // PromiseStubHook awaiting the embargo I suppose. Previous notes on embargoes:\r\n    // - Resolve message specifies last call that was received before the resolve. The introducer is\r\n    //   responsible for any embargoes up to that point.\r\n    // - Any further calls forwarded by the introducer after that point MUST immediately resolve to\r\n    //   a forwarded call. The caller is responsible for ensuring the last of these is handed off\r\n    //   before direct calls can be delivered.\r\n\r\n    if (this.localRefcount == 0) {\r\n      // Already disposed (canceled), so ignore the resolution and don't send a redundant release.\r\n      resolution.dispose();\r\n      return;\r\n    }\r\n\r\n    this.resolution = resolution;\r\n    this.sendRelease();\r\n\r\n    if (this.onBrokenRegistrations) {\r\n      // Delete all our callback registrations from this session and re-register them on the\r\n      // target stub.\r\n      for (let i of this.onBrokenRegistrations) {\r\n        let callback = this.session.onBrokenCallbacks[i];\r\n        let endIndex = this.session.onBrokenCallbacks.length;\r\n        resolution.onBroken(callback);\r\n        if (this.session.onBrokenCallbacks[endIndex] === callback) {\r\n          // Oh, calling onBroken() just registered the callback back on this connection again.\r\n          // But when the connection dies, we want all the callbacks to be called in the order in\r\n          // which they were registered. So we don't want this one pushed to the back of the line\r\n          // here. So, let's remove the newly-added registration and keep the original.\r\n          // TODO: This is quite hacky, think about whether this is really the right answer.\r\n          delete this.session.onBrokenCallbacks[endIndex];\r\n        } else {\r\n          // The callback is now registered elsewhere, so delete it from our session.\r\n          delete this.session.onBrokenCallbacks[i];\r\n        }\r\n      }\r\n      this.onBrokenRegistrations = undefined;\r\n    }\r\n\r\n    if (this.activePull) {\r\n      this.activePull.resolve();\r\n      this.activePull = undefined;\r\n    }\r\n  }\r\n\r\n  async awaitResolution(): Promise<RpcPayload> {\r\n    if (!this.activePull) {\r\n      this.session.sendPull(this.importId);\r\n      this.activePull = Promise.withResolvers<void>();\r\n    }\r\n    await this.activePull.promise;\r\n    return this.resolution!.pull();\r\n  }\r\n\r\n  dispose() {\r\n    if (this.resolution) {\r\n      this.resolution.dispose();\r\n    } else {\r\n      this.abort(new Error(\"RPC was canceled because the RpcPromise was disposed.\"));\r\n      this.sendRelease();\r\n    }\r\n  }\r\n\r\n  abort(error: any) {\r\n    if (!this.resolution) {\r\n      this.resolution = new ErrorStubHook(error);\r\n\r\n      if (this.activePull) {\r\n        this.activePull.reject(error);\r\n        this.activePull = undefined;\r\n      }\r\n\r\n      // The RpcSession itself will have called all our callbacks so we don't need to track the\r\n      // registrations anymore.\r\n      this.onBrokenRegistrations = undefined;\r\n    }\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    if (this.resolution) {\r\n      this.resolution.onBroken(callback);\r\n    } else {\r\n      let index = this.session.onBrokenCallbacks.length;\r\n      this.session.onBrokenCallbacks.push(callback);\r\n\r\n      if (!this.onBrokenRegistrations) this.onBrokenRegistrations = [];\r\n      this.onBrokenRegistrations.push(index);\r\n    }\r\n  }\r\n\r\n  private sendRelease() {\r\n    if (this.remoteRefcount > 0) {\r\n      this.session.sendRelease(this.importId, this.remoteRefcount);\r\n      this.remoteRefcount = 0;\r\n    }\r\n  }\r\n};\r\n\r\nclass RpcImportHook extends StubHook {\r\n  public entry?: ImportTableEntry;  // undefined when we're disposed\r\n\r\n  // `pulling` is true if we already expect that this import is going to be resolved later, and\r\n  // null if this import is not allowed to be pulled (i.e. it's a stub not a promise).\r\n  constructor(public isPromise: boolean, entry: ImportTableEntry) {\r\n    super();\r\n    ++entry.localRefcount;\r\n    this.entry = entry;\r\n  }\r\n\r\n  collectPath(path: PropertyPath): RpcImportHook {\r\n    return this;\r\n  }\r\n\r\n  getEntry(): ImportTableEntry {\r\n    if (this.entry) {\r\n      return this.entry;\r\n    } else {\r\n      // Shouldn't get here in practice since the holding stub should have replaced the hook when\r\n      // disposed.\r\n      throw new Error(\"This RpcImportHook was already disposed.\");\r\n    }\r\n  }\r\n\r\n  // -------------------------------------------------------------------------------------\r\n  // implements StubHook\r\n\r\n  call(path: PropertyPath, args: RpcPayload): StubHook {\r\n    let entry = this.getEntry();\r\n    if (entry.resolution) {\r\n      return entry.resolution.call(path, args);\r\n    } else {\r\n      return entry.session.sendCall(entry.importId, path, args);\r\n    }\r\n  }\r\n\r\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\r\n    let entry: ImportTableEntry;\r\n    try {\r\n      entry = this.getEntry();\r\n    } catch (err) {\r\n      for (let cap of captures) {\r\n        cap.dispose();\r\n      }\r\n      throw err;\r\n    }\r\n\r\n    if (entry.resolution) {\r\n      return entry.resolution.map(path, captures, instructions);\r\n    } else {\r\n      return entry.session.sendMap(entry.importId, path, captures, instructions);\r\n    }\r\n  }\r\n\r\n  get(path: PropertyPath): StubHook {\r\n    let entry = this.getEntry();\r\n    if (entry.resolution) {\r\n      return entry.resolution.get(path);\r\n    } else {\r\n      return entry.session.sendCall(entry.importId, path);\r\n    }\r\n  }\r\n\r\n  dup(): RpcImportHook {\r\n    return new RpcImportHook(false, this.getEntry());\r\n  }\r\n\r\n  pull(): RpcPayload | Promise<RpcPayload> {\r\n    let entry = this.getEntry();\r\n\r\n    if (!this.isPromise) {\r\n      throw new Error(\"Can't pull this hook because it's not a promise hook.\");\r\n    }\r\n\r\n    if (entry.resolution) {\r\n      return entry.resolution.pull();\r\n    }\r\n\r\n    return entry.awaitResolution();\r\n  }\r\n\r\n  ignoreUnhandledRejections(): void {\r\n    // We don't actually have to do anything here because this method only has to ignore rejections\r\n    // if pull() is *not* called, and if pull() is not called then we won't generate any rejections\r\n    // anyway.\r\n  }\r\n\r\n  dispose(): void {\r\n    let entry = this.entry;\r\n    this.entry = undefined;\r\n    if (entry) {\r\n      if (--entry.localRefcount === 0) {\r\n        entry.dispose();\r\n      }\r\n    }\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    if (this.entry) {\r\n      this.entry.onBroken(callback);\r\n    }\r\n  }\r\n}\r\n\r\nclass RpcMainHook extends RpcImportHook {\r\n  private session?: RpcSessionImpl;\r\n\r\n  constructor(entry: ImportTableEntry) {\r\n    super(false, entry);\r\n    this.session = entry.session;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.session) {\r\n      let session = this.session;\r\n      this.session = undefined;\r\n      session.shutdown();\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Options to customize behavior of an RPC session. All functions which start a session should\r\n * optionally accept this.\r\n */\r\nexport type RpcSessionOptions = {\r\n  /**\r\n   * If provided, this function will be called whenever an `Error` object is serialized (for any\r\n   * reason, not just because it was thrown). This can be used to log errors, and also to redact\r\n   * them.\r\n   *\r\n   * If `onSendError` returns an Error object, than object will be substituted in place of the\r\n   * original. If it has a stack property, the stack will be sent to the client.\r\n   *\r\n   * If `onSendError` doesn't return anything (or is not provided at all), the default behavior is\r\n   * to serialize the error with the stack omitted.\r\n   */\r\n  onSendError?: (error: Error) => Error | void;\r\n};\r\n\r\nclass RpcSessionImpl implements Importer, Exporter {\r\n  private exports: Array<ExportTableEntry> = [];\r\n  private reverseExports: Map<StubHook, ExportId> = new Map();\r\n  private imports: Array<ImportTableEntry> = [];\r\n  private abortReason?: any;\r\n  private cancelReadLoop: (error: any) => void;\r\n\r\n  // We assign positive numbers to imports we initiate, and negative numbers to exports we\r\n  // initiate. So the next import ID is just `imports.length`, but the next export ID needs\r\n  // to be tracked explicitly.\r\n  private nextExportId = -1;\r\n\r\n  // If set, call this when all incoming calls are complete.\r\n  private onBatchDone?: Omit<PromiseWithResolvers<void>, \"promise\">;\r\n\r\n  // How many promises is our peer expecting us to resolve?\r\n  private pullCount = 0;\r\n\r\n  // Sparse array of onBrokenCallback registrations. Items are strictly appended to the end but\r\n  // may be deleted from the middle (hence leaving the array sparse).\r\n  onBrokenCallbacks: ((error: any) => void)[] = [];\r\n\r\n  constructor(private transport: RpcTransport, mainHook: StubHook,\r\n      private options: RpcSessionOptions) {\r\n    // Export zero is automatically the bootstrap object.\r\n    this.exports.push({hook: mainHook, refcount: 1});\r\n\r\n    // Import zero is the other side's bootstrap object.\r\n    this.imports.push(new ImportTableEntry(this, 0, false));\r\n\r\n    let rejectFunc: (error: any) => void;;\r\n    let abortPromise = new Promise<never>((resolve, reject) => { rejectFunc = reject; });\r\n    this.cancelReadLoop = rejectFunc!;\r\n\r\n    this.readLoop(abortPromise).catch(err => this.abort(err));\r\n  }\r\n\r\n  // Should only be called once immediately after construction.\r\n  getMainImport(): RpcImportHook {\r\n    return new RpcMainHook(this.imports[0]);\r\n  }\r\n\r\n  shutdown(): void {\r\n    // TODO(someday): Should we add some sort of \"clean shutdown\" mechanism? This gets the job\r\n    //   done just fine for the moment.\r\n    this.abort(new Error(\"RPC session was shut down by disposing the main stub\"), false);\r\n  }\r\n\r\n  exportStub(hook: StubHook): ExportId {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    let existingExportId = this.reverseExports.get(hook);\r\n    if (existingExportId !== undefined) {\r\n      ++this.exports[existingExportId].refcount;\r\n      return existingExportId;\r\n    } else {\r\n      let exportId = this.nextExportId--;\r\n      this.exports[exportId] = { hook, refcount: 1 };\r\n      this.reverseExports.set(hook, exportId);\r\n      // TODO: Use onBroken().\r\n      return exportId;\r\n    }\r\n  }\r\n\r\n  exportPromise(hook: StubHook): ExportId {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    // Promises always use a new ID because otherwise the recipient could miss the resolution.\r\n    let exportId = this.nextExportId--;\r\n    this.exports[exportId] = { hook, refcount: 1 };\r\n    this.reverseExports.set(hook, exportId);\r\n\r\n    // Automatically start resolving any promises we send.\r\n    this.ensureResolvingExport(exportId);\r\n    return exportId;\r\n  }\r\n\r\n  unexport(ids: Array<ExportId>): void {\r\n    for (let id of ids) {\r\n      this.releaseExport(id, 1);\r\n    }\r\n  }\r\n\r\n  private releaseExport(exportId: ExportId, refcount: number) {\r\n    let entry = this.exports[exportId];\r\n    if (!entry) {\r\n      throw new Error(`no such export ID: ${exportId}`);\r\n    }\r\n    if (entry.refcount < refcount) {\r\n      throw new Error(`refcount would go negative: ${entry.refcount} < ${refcount}`);\r\n    }\r\n    entry.refcount -= refcount;\r\n    if (entry.refcount === 0) {\r\n      delete this.exports[exportId];\r\n      this.reverseExports.delete(entry.hook);\r\n      entry.hook.dispose();\r\n    }\r\n  }\r\n\r\n  onSendError(error: Error): Error | void {\r\n    if (this.options.onSendError) {\r\n      return this.options.onSendError(error);\r\n    }\r\n  }\r\n\r\n  private ensureResolvingExport(exportId: ExportId) {\r\n    let exp = this.exports[exportId];\r\n    if (!exp) {\r\n      throw new Error(`no such export ID: ${exportId}`);\r\n    }\r\n    if (!exp.pull) {\r\n      let resolve = async () => {\r\n        let hook = exp.hook;\r\n        for (;;) {\r\n          let payload = await hook.pull();\r\n          if (payload.value instanceof RpcStub) {\r\n            let {hook: inner, pathIfPromise} = unwrapStubAndPath(payload.value);\r\n            if (pathIfPromise && pathIfPromise.length == 0) {\r\n              if (this.getImport(hook) === undefined) {\r\n                // Optimization: The resolution is just another promise, and it is not a promise\r\n                // pointing back to the peer. So if we send a resolve message, it's just going to\r\n                // resolve to another new promise export, which is just going to have to wait for\r\n                // another resolve message later. This intermediate resolve message gives the peer\r\n                // no useful information, so let's skip it and just wait for the chained\r\n                // resolution.\r\n                hook = inner;\r\n                continue;\r\n              }\r\n            }\r\n          }\r\n\r\n          return payload;\r\n        }\r\n      };\r\n\r\n      ++this.pullCount;\r\n      exp.pull = resolve().then(\r\n        payload => {\r\n          // We don't transfer ownership of stubs in the payload since the payload\r\n          // belongs to the hook which sticks around to handle pipelined requests.\r\n          let value = Devaluator.devaluate(payload.value, undefined, this, payload);\r\n          this.send([\"resolve\", exportId, value]);\r\n        },\r\n        error => {\r\n          this.send([\"reject\", exportId, Devaluator.devaluate(error, undefined, this)]);\r\n        }\r\n      ).catch(\r\n        error => {\r\n          // If serialization failed, report the serialization error, which should\r\n          // itself always be serializable.\r\n          try {\r\n            this.send([\"reject\", exportId, Devaluator.devaluate(error, undefined, this)]);\r\n          } catch (error2) {\r\n            // TODO: Shouldn't happen, now what?\r\n            this.abort(error2);\r\n          }\r\n        }\r\n      ).finally(() => {\r\n        if (--this.pullCount === 0) {\r\n          if (this.onBatchDone) {\r\n            this.onBatchDone.resolve();\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  getImport(hook: StubHook): ImportId | undefined {\r\n    if (hook instanceof RpcImportHook && hook.entry && hook.entry.session === this) {\r\n      return hook.entry.importId;\r\n    } else {\r\n      return undefined;\r\n    }\r\n  }\r\n\r\n  importStub(idx: ImportId): RpcImportHook {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    let entry = this.imports[idx];\r\n    if (!entry) {\r\n      entry = new ImportTableEntry(this, idx, false);\r\n      this.imports[idx] = entry;\r\n    }\r\n    return new RpcImportHook(/*isPromise=*/false, entry);\r\n  }\r\n\r\n  importPromise(idx: ImportId): StubHook {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    if (this.imports[idx]) {\r\n      // Can't reuse an existing ID for a promise!\r\n      return new ErrorStubHook(new Error(\r\n          \"Bug in RPC system: The peer sent a promise reusing an existing export ID.\"));\r\n    }\r\n\r\n    // Create an already-pulling hook.\r\n    let entry = new ImportTableEntry(this, idx, true);\r\n    this.imports[idx] = entry;\r\n    return new RpcImportHook(/*isPromise=*/true, entry);\r\n  }\r\n\r\n  getExport(idx: ExportId): StubHook | undefined {\r\n    return this.exports[idx]?.hook;\r\n  }\r\n\r\n  private send(msg: any) {\r\n    if (this.abortReason !== undefined) {\r\n      // Ignore sends after we've aborted.\r\n      return;\r\n    }\r\n\r\n    let msgText: string;\r\n    try {\r\n      msgText = JSON.stringify(msg);\r\n    } catch (err) {\r\n      // If JSON stringification failed, there's something wrong with the devaluator, as it should\r\n      // not allow non-JSONable values to be injected in the first place.\r\n      try { this.abort(err); } catch (err2) {}\r\n      throw err;\r\n    }\r\n\r\n    this.transport.send(msgText)\r\n        // If send fails, abort the connection, but don't try to send an abort message since\r\n        // that'll probably also fail.\r\n        .catch(err => this.abort(err, false));\r\n  }\r\n\r\n  sendCall(id: ImportId, path: PropertyPath, args?: RpcPayload): RpcImportHook {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    let value: Array<any> = [\"pipeline\", id, path];\r\n    if (args) {\r\n      let devalue = Devaluator.devaluate(args.value, undefined, this, args);\r\n\r\n      // HACK: Since the args is an array, devaluator will wrap in a second array. Need to unwrap.\r\n      // TODO: Clean this up somehow.\r\n      value.push((<Array<unknown>>devalue)[0]);\r\n\r\n      // Serializing the payload takes ownership of all stubs within, so the payload itself does\r\n      // not need to be disposed.\r\n    }\r\n    this.send([\"push\", value]);\r\n\r\n    let entry = new ImportTableEntry(this, this.imports.length, false);\r\n    this.imports.push(entry);\r\n    return new RpcImportHook(/*isPromise=*/true, entry);\r\n  }\r\n\r\n  sendMap(id: ImportId, path: PropertyPath, captures: StubHook[], instructions: unknown[])\r\n      : RpcImportHook {\r\n    if (this.abortReason) {\r\n      for (let cap of captures) {\r\n        cap.dispose();\r\n      }\r\n      throw this.abortReason;\r\n    }\r\n\r\n    let devaluedCaptures = captures.map(hook => {\r\n      let importId = this.getImport(hook);\r\n      if (importId !== undefined) {\r\n        return [\"import\", importId];\r\n      } else {\r\n        return [\"export\", this.exportStub(hook)];\r\n      }\r\n    });\r\n\r\n    let value = [\"remap\", id, path, devaluedCaptures, instructions];\r\n\r\n    this.send([\"push\", value]);\r\n\r\n    let entry = new ImportTableEntry(this, this.imports.length, false);\r\n    this.imports.push(entry);\r\n    return new RpcImportHook(/*isPromise=*/true, entry);\r\n  }\r\n\r\n  sendPull(id: ImportId) {\r\n    if (this.abortReason) throw this.abortReason;\r\n\r\n    this.send([\"pull\", id]);\r\n  }\r\n\r\n  sendRelease(id: ImportId, remoteRefcount: number) {\r\n    if (this.abortReason) return;\r\n\r\n    this.send([\"release\", id, remoteRefcount]);\r\n    delete this.imports[id];\r\n  }\r\n\r\n  abort(error: any, trySendAbortMessage: boolean = true) {\r\n    // Don't double-abort.\r\n    if (this.abortReason !== undefined) return;\r\n\r\n    this.cancelReadLoop(error);\r\n\r\n    if (trySendAbortMessage) {\r\n      try {\r\n        this.transport.send(JSON.stringify([\"abort\", Devaluator\r\n            .devaluate(error, undefined, this)]))\r\n            .catch(err => {});\r\n      } catch (err) {\r\n        // ignore, probably the whole reason we're aborting is because the transport is broken\r\n      }\r\n    }\r\n\r\n    if (error === undefined) {\r\n      // Shouldn't happen, but if it does, avoid setting `abortReason` to `undefined`.\r\n      error = \"undefined\";\r\n    }\r\n\r\n    this.abortReason = error;\r\n    if (this.onBatchDone) {\r\n      this.onBatchDone.reject(error);\r\n    }\r\n\r\n    if (this.transport.abort) {\r\n      // Call transport's abort handler, but guard against buggy app code.\r\n      try {\r\n        this.transport.abort(error);\r\n      } catch (err) {\r\n        // Treat as unhandled rejection.\r\n        Promise.resolve(err);\r\n      }\r\n    }\r\n\r\n    // WATCH OUT: these are sparse arrays. `for/let/of` will iterate only positive indexes\r\n    // including deleted indexes -- bad. We need to use `for/let/in` instead.\r\n    for (let i in this.onBrokenCallbacks) {\r\n      try {\r\n        this.onBrokenCallbacks[i](error);\r\n      } catch (err) {\r\n        // Treat as unhandled rejection.\r\n        Promise.resolve(err);\r\n      }\r\n    }\r\n    for (let i in this.imports) {\r\n      this.imports[i].abort(error);\r\n    }\r\n    for (let i in this.exports) {\r\n      this.exports[i].hook.dispose();\r\n    }\r\n  }\r\n\r\n  private async readLoop(abortPromise: Promise<never>) {\r\n    while (!this.abortReason) {\r\n      let msg = JSON.parse(await Promise.race([this.transport.receive(), abortPromise]));\r\n      if (this.abortReason) break;  // check again before processing\r\n\r\n      if (msg instanceof Array) {\r\n        switch (msg[0]) {\r\n          case \"push\":  // [\"push\", Expression]\r\n            if (msg.length > 1) {\r\n              let payload = new Evaluator(this).evaluate(msg[1]);\r\n              let hook = new PayloadStubHook(payload);\r\n\r\n              // It's possible for a rejection to occur before the client gets a chance to send\r\n              // a \"pull\" message or to use the promise in a pipeline. We don't want that to be\r\n              // treated as an unhandled rejection on our end.\r\n              hook.ignoreUnhandledRejections();\r\n\r\n              this.exports.push({ hook, refcount: 1 });\r\n              continue;\r\n            }\r\n            break;\r\n\r\n          case \"pull\": {  // [\"pull\", ImportId]\r\n            let exportId = msg[1];\r\n            if (typeof exportId == \"number\") {\r\n              this.ensureResolvingExport(exportId);\r\n              continue;\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"resolve\":   // [\"resolve\", ExportId, Expression]\r\n          case \"reject\": {  // [\"reject\", ExportId, Expression]\r\n            let importId = msg[1];\r\n            if (typeof importId == \"number\" && msg.length > 2) {\r\n              let imp = this.imports[importId];\r\n              if (imp) {\r\n                if (msg[0] == \"resolve\") {\r\n                  imp.resolve(new PayloadStubHook(new Evaluator(this).evaluate(msg[2])));\r\n                } else {\r\n                  // HACK: We expect errors are always simple values (no stubs) so we can just\r\n                  //   pull the value out of the payload.\r\n                  let payload = new Evaluator(this).evaluate(msg[2]);\r\n                  payload.dispose();  // just in case -- should be no-op\r\n                  imp.resolve(new ErrorStubHook(payload.value));\r\n                }\r\n              } else {\r\n                // Import ID is not found on the table. Probably we released it already, in which\r\n                // case we do not care about the resolution, so whatever.\r\n\r\n                if (msg[0] == \"resolve\") {\r\n                  // We need to evaluate the resolution and immediately dispose it so that we\r\n                  // release any stubs it contains.\r\n                  new Evaluator(this).evaluate(msg[2]).dispose();\r\n                }\r\n              }\r\n              continue;\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"release\": {\r\n            let exportId = msg[1];\r\n            let refcount = msg[2];\r\n            if (typeof exportId == \"number\" && typeof refcount == \"number\") {\r\n              this.releaseExport(exportId, refcount);\r\n              continue;\r\n            }\r\n            break;\r\n          }\r\n\r\n          case \"abort\": {\r\n            let payload = new Evaluator(this).evaluate(msg[1]);\r\n            payload.dispose();  // just in case -- should be no-op\r\n            this.abort(payload, false);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      throw new Error(`bad RPC message: ${JSON.stringify(msg)}`);\r\n    }\r\n  }\r\n\r\n  async drain(): Promise<void> {\r\n    if (this.abortReason) {\r\n      throw this.abortReason;\r\n    }\r\n\r\n    if (this.pullCount > 0) {\r\n      let {promise, resolve, reject} = Promise.withResolvers<void>();\r\n      this.onBatchDone = {resolve, reject};\r\n      await promise;\r\n    }\r\n  }\r\n\r\n  getStats(): {imports: number, exports: number} {\r\n    let result = {imports: 0, exports: 0};\r\n    // We can't just use `.length` because the arrays can be sparse and can have negative indexes.\r\n    for (let i in this.imports) {\r\n      ++result.imports;\r\n    }\r\n    for (let i in this.exports) {\r\n      ++result.exports;\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n// Public interface that wraps RpcSession and hides private implementation details (even from\r\n// JavaScript with no type enforcement).\r\nexport class RpcSession {\r\n  #session: RpcSessionImpl;\r\n  #mainStub: RpcStub;\r\n\r\n  constructor(transport: RpcTransport, localMain?: any, options: RpcSessionOptions = {}) {\r\n    let mainHook: StubHook;\r\n    if (localMain) {\r\n      mainHook = new PayloadStubHook(RpcPayload.fromAppReturn(localMain));\r\n    } else {\r\n      mainHook = new ErrorStubHook(new Error(\"This connection has no main object.\"));\r\n    }\r\n    this.#session = new RpcSessionImpl(transport, mainHook, options);\r\n    this.#mainStub = new RpcStub(this.#session.getMainImport());\r\n  }\r\n\r\n  getRemoteMain(): RpcStub {\r\n    return this.#mainStub;\r\n  }\r\n\r\n  getStats(): {imports: number, exports: number} {\r\n    return this.#session.getStats();\r\n  }\r\n\r\n  drain(): Promise<void> {\r\n    return this.#session.drain();\r\n  }\r\n}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\n/// <reference types=\"@cloudflare/workers-types\" />\r\n\r\nimport { RpcStub } from \"./core.js\";\r\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\r\n\r\nexport function newWebSocketRpcSession(\r\n    webSocket: WebSocket | string, localMain?: any, options?: RpcSessionOptions): RpcStub {\r\n  if (typeof webSocket === \"string\") {\r\n    webSocket = new WebSocket(webSocket);\r\n  }\r\n\r\n  let transport = new WebSocketTransport(webSocket);\r\n  let rpc = new RpcSession(transport, localMain, options);\r\n  return rpc.getRemoteMain();\r\n}\r\n\r\n/**\r\n * For use in Cloudflare Workers: Construct an HTTP response that starts a WebSocket RPC session\r\n * with the given `localMain`.\r\n */\r\nexport function newWorkersWebSocketRpcResponse(\r\n    request: Request, localMain?: any, options?: RpcSessionOptions): Response {\r\n  if (request.headers.get(\"Upgrade\")?.toLowerCase() !== \"websocket\") {\r\n    return new Response(\"This endpoint only accepts WebSocket requests.\", { status: 400 });\r\n  }\r\n\r\n  let pair = new WebSocketPair();\r\n  let server = pair[0];\r\n  server.accept()\r\n  newWebSocketRpcSession(server, localMain, options);\r\n  return new Response(null, {\r\n    status: 101,\r\n    webSocket: pair[1],\r\n  });\r\n}\r\n\r\nclass WebSocketTransport implements RpcTransport {\r\n  constructor (webSocket: WebSocket) {\r\n    this.#webSocket = webSocket;\r\n\r\n    if (webSocket.readyState === WebSocket.CONNECTING) {\r\n      this.#sendQueue = [];\r\n      webSocket.addEventListener(\"open\", event => {\r\n        try {\r\n          for (let message of this.#sendQueue!) {\r\n            webSocket.send(message);\r\n          }\r\n        } catch (err) {\r\n          this.#receivedError(err);\r\n        }\r\n        this.#sendQueue = undefined;\r\n      });\r\n    }\r\n\r\n    webSocket.addEventListener(\"message\", (event: MessageEvent<any>) => {\r\n      if (this.#error) {\r\n        // Ignore further messages.\r\n      } else if (typeof event.data === \"string\") {\r\n        if (this.#receiveResolver) {\r\n          this.#receiveResolver(event.data);\r\n          this.#receiveResolver = undefined;\r\n          this.#receiveRejecter = undefined;\r\n        } else {\r\n          this.#receiveQueue.push(event.data);\r\n        }\r\n      } else {\r\n        this.#receivedError(new TypeError(\"Received non-string message from WebSocket.\"));\r\n      }\r\n    });\r\n\r\n    webSocket.addEventListener(\"close\", (event: CloseEvent) => {\r\n      this.#receivedError(new Error(`Peer closed WebSocket: ${event.code} ${event.reason}`));\r\n    });\r\n\r\n    webSocket.addEventListener(\"error\", (event: Event) => {\r\n      this.#receivedError(new Error(`WebSocket connection failed.`));\r\n    });\r\n  }\r\n\r\n  #webSocket: WebSocket;\r\n  #sendQueue?: string[];  // only if not opened yet\r\n  #receiveResolver?: (message: string) => void;\r\n  #receiveRejecter?: (err: any) => void;\r\n  #receiveQueue: string[] = [];\r\n  #error?: any;\r\n\r\n  async send(message: string): Promise<void> {\r\n    if (this.#sendQueue === undefined) {\r\n      this.#webSocket.send(message);\r\n    } else {\r\n      // Not open yet, queue for later.\r\n      this.#sendQueue.push(message);\r\n    }\r\n  }\r\n\r\n  async receive(): Promise<string> {\r\n    if (this.#receiveQueue.length > 0) {\r\n      return this.#receiveQueue.shift()!;\r\n    } else if (this.#error) {\r\n      throw this.#error;\r\n    } else {\r\n      return new Promise<string>((resolve, reject) => {\r\n        this.#receiveResolver = resolve;\r\n        this.#receiveRejecter = reject;\r\n      });\r\n    }\r\n  }\r\n\r\n  abort?(reason: any): void {\r\n    let message: string;\r\n    if (reason instanceof Error) {\r\n      message = reason.message;\r\n    } else {\r\n      message = `${reason}`;\r\n    }\r\n    this.#webSocket.close(3000, message);\r\n\r\n    if (!this.#error) {\r\n      this.#error = reason;\r\n      // No need to call receiveRejecter(); RPC implementation will stop listening anyway.\r\n    }\r\n  }\r\n\r\n  #receivedError(reason: any) {\r\n    if (!this.#error) {\r\n      this.#error = reason;\r\n      if (this.#receiveRejecter) {\r\n        this.#receiveRejecter(reason);\r\n        this.#receiveResolver = undefined;\r\n        this.#receiveRejecter = undefined;\r\n      }\r\n    }\r\n  }\r\n}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { RpcStub } from \"./core.js\";\r\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\r\nimport type { IncomingMessage, ServerResponse, OutgoingHttpHeader, OutgoingHttpHeaders } from \"node:http\";\r\n\r\ntype SendBatchFunc = (batch: string[]) => Promise<string[]>;\r\n\r\nclass BatchClientTransport implements RpcTransport {\r\n  constructor(sendBatch: SendBatchFunc) {\r\n    this.#promise = this.#scheduleBatch(sendBatch);\r\n  }\r\n\r\n  #promise: Promise<void>;\r\n  #aborted: any;\r\n\r\n  #batchToSend: string[] | null = [];\r\n  #batchToReceive: string[] | null = null;\r\n\r\n  async send(message: string): Promise<void> {\r\n    // If the batch was already sent, we just ignore the message, because throwing may cause the\r\n    // RPC system to abort prematurely. Once the last receive() is done then we'll throw an error\r\n    // that aborts the RPC system at the right time and will propagate to all other requests.\r\n    if (this.#batchToSend !== null) {\r\n      this.#batchToSend.push(message);\r\n    }\r\n  }\r\n\r\n  async receive(): Promise<string> {\r\n    if (!this.#batchToReceive) {\r\n      await this.#promise;\r\n    }\r\n\r\n    let msg = this.#batchToReceive!.shift();\r\n    if (msg !== undefined) {\r\n      return msg;\r\n    } else {\r\n      // No more messages. An error thrown here will propagate out of any calls that are still\r\n      // open.\r\n      throw new Error(\"Batch RPC request ended.\");\r\n    }\r\n  }\r\n\r\n  abort?(reason: any): void {\r\n    this.#aborted = reason;\r\n  }\r\n\r\n  async #scheduleBatch(sendBatch: SendBatchFunc) {\r\n    // Wait for microtask queue to clear before sending a batch.\r\n    //\r\n    // Note that simply waiting for one turn of the microtask queue (await Promise.resolve()) is\r\n    // not good enough here as the application needs a chance to call `.then()` on every RPC\r\n    // promise in order to explicitly indicate they want the results. Unfortunately, `await`ing\r\n    // a thenable does not call `.then()` immediately -- for some reason it waits for a turn of\r\n    // the microtask queue first, *then* calls `.then()`.\r\n    await new Promise(resolve => setTimeout(resolve, 0));\r\n\r\n    if (this.#aborted !== undefined) {\r\n      throw this.#aborted;\r\n    }\r\n\r\n    let batch = this.#batchToSend!;\r\n    this.#batchToSend = null;\r\n    this.#batchToReceive = await sendBatch(batch);\r\n  }\r\n}\r\n\r\nexport function newHttpBatchRpcSession(\r\n    urlOrRequest: string | Request, options?: RpcSessionOptions): RpcStub {\r\n  let sendBatch: SendBatchFunc = async (batch: string[]) => {\r\n    let response = await fetch(urlOrRequest, {\r\n      method: \"POST\",\r\n      body: batch.join(\"\\n\"),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      response.body?.cancel();\r\n      throw new Error(`RPC request failed: ${response.status} ${response.statusText}`);\r\n    }\r\n\r\n    let body = await response.text();\r\n    return body == \"\" ? [] : body.split(\"\\n\");\r\n  };\r\n\r\n  let transport = new BatchClientTransport(sendBatch);\r\n  let rpc = new RpcSession(transport, undefined, options);\r\n  return rpc.getRemoteMain();\r\n}\r\n\r\nclass BatchServerTransport implements RpcTransport {\r\n  constructor(batch: string[]) {\r\n    this.#batchToReceive = batch;\r\n  }\r\n\r\n  #batchToSend: string[] = [];\r\n  #batchToReceive: string[];\r\n  #allReceived: PromiseWithResolvers<void> = Promise.withResolvers<void>();\r\n\r\n  async send(message: string): Promise<void> {\r\n    this.#batchToSend.push(message);\r\n  }\r\n\r\n  async receive(): Promise<string> {\r\n    let msg = this.#batchToReceive!.shift();\r\n    if (msg !== undefined) {\r\n      return msg;\r\n    } else {\r\n      // No more messages.\r\n      this.#allReceived.resolve();\r\n      return new Promise(r => {});\r\n    }\r\n  }\r\n\r\n  abort?(reason: any): void {\r\n    this.#allReceived.reject(reason);\r\n  }\r\n\r\n  whenAllReceived() {\r\n    return this.#allReceived.promise;\r\n  }\r\n\r\n  getResponseBody(): string {\r\n    return this.#batchToSend.join(\"\\n\");\r\n  }\r\n}\r\n\r\n/**\r\n * Implements the server end of an HTTP batch session, using standard Fetch API types to represent\r\n * HTTP requests and responses.\r\n *\r\n * @param request The request received from the client initiating the session.\r\n * @param localMain The main stub or RpcTarget which the server wishes to expose to the client.\r\n * @param options Optional RPC session options.\r\n * @returns The HTTP response to return to the client. Note that the returned object has mutable\r\n *     headers, so you can modify them using e.g. `response.headers.set(\"Foo\", \"bar\")`.\r\n */\r\nexport async function newHttpBatchRpcResponse(\r\n    request: Request, localMain: any, options?: RpcSessionOptions): Promise<Response> {\r\n  if (request.method !== \"POST\") {\r\n    return new Response(\"This endpoint only accepts POST requests.\", { status: 405 });\r\n  }\r\n\r\n  let body = await request.text();\r\n  let batch = body === \"\" ? [] : body.split(\"\\n\");\r\n\r\n  let transport = new BatchServerTransport(batch);\r\n  let rpc = new RpcSession(transport, localMain, options);\r\n\r\n  // TODO: Arguably we should arrange so any attempts to pull promise resolutions from the client\r\n  //   will reject rather than just hang. But it IS valid to make server->client calls in order to\r\n  //   then pipeline the result into something returned to the client. We don't want the errors to\r\n  //   prematurely cancel anything that would eventually complete. So for now we just say, it's the\r\n  //   app's responsibility to not wait on any server -> client calls since they will never\r\n  //   complete.\r\n\r\n  await transport.whenAllReceived();\r\n  await rpc.drain();\r\n\r\n  // TODO: Ask RpcSession to dispose everything it is still holding on to?\r\n\r\n  return new Response(transport.getResponseBody());\r\n}\r\n\r\n/**\r\n * Implements the server end of an HTTP batch session using traditional Node.js HTTP APIs.\r\n *\r\n * @param request The request received from the client initiating the session.\r\n * @param response The response object, to which the response should be written.\r\n * @param localMain The main stub or RpcTarget which the server wishes to expose to the client.\r\n * @param options Optional RPC session options. You can also pass headers to set on the response.\r\n */\r\nexport async function nodeHttpBatchRpcResponse(\r\n    request: IncomingMessage, response: ServerResponse,\r\n    localMain: any,\r\n    options?: RpcSessionOptions & {\r\n      headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],\r\n    }): Promise<void> {\r\n  if (request.method !== \"POST\") {\r\n    response.writeHead(405, \"This endpoint only accepts POST requests.\");\r\n  }\r\n\r\n  let body = await new Promise<string>((resolve, reject) => {\r\n    let chunks: Buffer[] = [];\r\n    request.on(\"data\", chunk => {\r\n      chunks.push(chunk);\r\n    });\r\n    request.on(\"end\", () => {\r\n      resolve(Buffer.concat(chunks).toString());\r\n    });\r\n    request.on(\"error\", reject);\r\n  });\r\n  let batch = body === \"\" ? [] : body.split(\"\\n\");\r\n\r\n  let transport = new BatchServerTransport(batch);\r\n  let rpc = new RpcSession(transport, localMain, options);\r\n\r\n  await transport.whenAllReceived();\r\n  await rpc.drain();\r\n\r\n  response.writeHead(200, options?.headers);\r\n  response.end(transport.getResponseBody());\r\n}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { RpcStub } from \"./core.js\";\r\nimport { RpcTransport, RpcSession, RpcSessionOptions } from \"./rpc.js\";\r\n\r\n// Start a MessagePort session given a MessagePort or a pair of MessagePorts.\r\n//\r\n// `localMain` is the main RPC interface to expose to the peer. Returns a stub for the main\r\n// interface exposed from the peer.\r\nexport function newMessagePortRpcSession(\r\n    port: MessagePort, localMain?: any, options?: RpcSessionOptions): RpcStub {\r\n  let transport = new MessagePortTransport(port);\r\n  let rpc = new RpcSession(transport, localMain, options);\r\n  return rpc.getRemoteMain();\r\n}\r\n\r\nclass MessagePortTransport implements RpcTransport {\r\n  constructor (port: MessagePort) {\r\n    this.#port = port;\r\n\r\n    // Start listening for messages\r\n    port.start();\r\n\r\n    port.addEventListener(\"message\", (event: MessageEvent<any>) => {\r\n      if (this.#error) {\r\n        // Ignore further messages.\r\n      } else if (event.data === null) {\r\n        // Peer is signaling that they're closing the connection\r\n        this.#receivedError(new Error(\"Peer closed MessagePort connection.\"));\r\n      } else if (typeof event.data === \"string\") {\r\n        if (this.#receiveResolver) {\r\n          this.#receiveResolver(event.data);\r\n          this.#receiveResolver = undefined;\r\n          this.#receiveRejecter = undefined;\r\n        } else {\r\n          this.#receiveQueue.push(event.data);\r\n        }\r\n      } else {\r\n        this.#receivedError(new TypeError(\"Received non-string message from MessagePort.\"));\r\n      }\r\n    });\r\n\r\n    port.addEventListener(\"messageerror\", (event: MessageEvent) => {\r\n      this.#receivedError(new Error(\"MessagePort message error.\"));\r\n    });\r\n  }\r\n\r\n  #port: MessagePort;\r\n  #receiveResolver?: (message: string) => void;\r\n  #receiveRejecter?: (err: any) => void;\r\n  #receiveQueue: string[] = [];\r\n  #error?: any;\r\n\r\n  async send(message: string): Promise<void> {\r\n    if (this.#error) {\r\n      throw this.#error;\r\n    }\r\n    this.#port.postMessage(message);\r\n  }\r\n\r\n  async receive(): Promise<string> {\r\n    if (this.#receiveQueue.length > 0) {\r\n      return this.#receiveQueue.shift()!;\r\n    } else if (this.#error) {\r\n      throw this.#error;\r\n    } else {\r\n      return new Promise<string>((resolve, reject) => {\r\n        this.#receiveResolver = resolve;\r\n        this.#receiveRejecter = reject;\r\n      });\r\n    }\r\n  }\r\n\r\n  abort?(reason: any): void {\r\n    // Send close signal to peer before closing\r\n    try {\r\n      this.#port.postMessage(null);\r\n    } catch (err) {\r\n      // Ignore errors when sending close signal - port might already be closed\r\n    }\r\n\r\n    this.#port.close();\r\n\r\n    if (!this.#error) {\r\n      this.#error = reason;\r\n      // No need to call receiveRejecter(); RPC implementation will stop listening anyway.\r\n    }\r\n  }\r\n\r\n  #receivedError(reason: any) {\r\n    if (!this.#error) {\r\n      this.#error = reason;\r\n      if (this.#receiveRejecter) {\r\n        this.#receiveRejecter(reason);\r\n        this.#receiveResolver = undefined;\r\n        this.#receiveRejecter = undefined;\r\n      }\r\n    }\r\n  }\r\n}","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { StubHook, PropertyPath, RpcPayload, RpcStub, RpcPromise, withCallInterceptor, ErrorStubHook, mapImpl, PayloadStubHook, unwrapStubAndPath, unwrapStubNoProperties } from \"./core.js\";\r\nimport { Devaluator, Exporter, Importer, ExportId, ImportId, Evaluator } from \"./serialize.js\";\r\n\r\nlet currentMapBuilder: MapBuilder | undefined;\r\n\r\n// We use this type signature when building the instructions for type checking purposes. It\r\n// describes a subset of the overall RPC protocol.\r\nexport type MapInstruction =\r\n    | [\"pipeline\", number, PropertyPath]\r\n    | [\"pipeline\", number, PropertyPath, unknown]\r\n    | [\"remap\", number, PropertyPath, [\"import\", number][], MapInstruction[]]\r\n\r\nclass MapBuilder implements Exporter {\r\n  private context:\r\n    | {parent: undefined, captures: StubHook[], subject: StubHook, path: PropertyPath}\r\n    | {parent: MapBuilder, captures: number[], subject: number, path: PropertyPath};\r\n  private captureMap: Map<StubHook, number> = new Map();\r\n\r\n  private instructions: MapInstruction[] = [];\r\n\r\n  constructor(subject: StubHook, path: PropertyPath) {\r\n    if (currentMapBuilder) {\r\n      this.context = {\r\n        parent: currentMapBuilder,\r\n        captures: [],\r\n        subject: currentMapBuilder.capture(subject),\r\n        path\r\n      };\r\n    } else {\r\n      this.context = {\r\n        parent: undefined,\r\n        captures: [],\r\n        subject,\r\n        path\r\n      };\r\n    }\r\n\r\n    currentMapBuilder = this;\r\n  }\r\n\r\n  unregister() {\r\n    currentMapBuilder = this.context.parent;\r\n  }\r\n\r\n  makeInput(): MapVariableHook {\r\n    return new MapVariableHook(this, 0);\r\n  }\r\n\r\n  makeOutput(result: RpcPayload): StubHook {\r\n    let devalued: unknown;\r\n    try {\r\n      devalued = Devaluator.devaluate(result.value, undefined, this, result);\r\n    } finally {\r\n      result.dispose();\r\n    }\r\n\r\n    // The result is the final instruction. This doesn't actually fit our MapInstruction type\r\n    // signature, so we cheat a bit.\r\n    this.instructions.push(<any>devalued);\r\n\r\n    if (this.context.parent) {\r\n      this.context.parent.instructions.push(\r\n        [\"remap\", this.context.subject, this.context.path,\r\n                  this.context.captures.map(cap => [\"import\", cap]),\r\n                  this.instructions]\r\n      );\r\n      return new MapVariableHook(this.context.parent, this.context.parent.instructions.length);\r\n    } else {\r\n      return this.context.subject.map(this.context.path, this.context.captures, this.instructions);\r\n    }\r\n  }\r\n\r\n  pushCall(hook: StubHook, path: PropertyPath, params: RpcPayload): StubHook {\r\n    let devalued = Devaluator.devaluate(params.value, undefined, this, params);\r\n    // HACK: Since the args is an array, devaluator will wrap in a second array. Need to unwrap.\r\n    // TODO: Clean this up somehow.\r\n    devalued = (<Array<unknown>>devalued)[0];\r\n\r\n    let subject = this.capture(hook.dup());\r\n    this.instructions.push([\"pipeline\", subject, path, devalued]);\r\n    return new MapVariableHook(this, this.instructions.length);\r\n  }\r\n\r\n  pushGet(hook: StubHook, path: PropertyPath): StubHook {\r\n    let subject = this.capture(hook.dup());\r\n    this.instructions.push([\"pipeline\", subject, path]);\r\n    return new MapVariableHook(this, this.instructions.length);\r\n  }\r\n\r\n  capture(hook: StubHook): number {\r\n    if (hook instanceof MapVariableHook && hook.mapper === this) {\r\n      // Oh, this is already our own hook.\r\n      return hook.idx;\r\n    }\r\n\r\n    // TODO: Well, the hooks passed in are always unique, so they'll never exist in captureMap.\r\n    //   I suppose this is a problem with RPC as well. We need a way to identify hooks that are\r\n    //   dupes of the same target.\r\n    let result = this.captureMap.get(hook);\r\n    if (result === undefined) {\r\n      if (this.context.parent) {\r\n        let parentIdx = this.context.parent.capture(hook);\r\n        this.context.captures.push(parentIdx);\r\n      } else {\r\n        this.context.captures.push(hook);\r\n      }\r\n      result = -this.context.captures.length;\r\n      this.captureMap.set(hook, result);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // ---------------------------------------------------------------------------\r\n  // implements Exporter\r\n\r\n  exportStub(hook: StubHook): ExportId {\r\n    // It appears someone did something like:\r\n    //\r\n    //     stub.map(x => { return x.doSomething(new MyRpcTarget()); })\r\n    //\r\n    // That... won't work. They need to do this instead:\r\n    //\r\n    //     using myTargetStub = new RpcStub(new MyRpcTarget());\r\n    //     stub.map(x => { return x.doSomething(myTargetStub.dup()); })\r\n    //\r\n    // TODO(someday): Consider carefully if the inline syntax is maybe OK. If so, perhaps the\r\n    //   serializer could try calling `getImport()` even for known-local hooks.\r\n    // TODO(someday): Do we need to support rpc-thenable somehow?\r\n    throw new Error(\r\n        \"Can't construct an RpcTarget or RPC callback inside a mapper function. Try creating a \" +\r\n        \"new RpcStub outside the callback first, then using it inside the callback.\");\r\n  }\r\n  exportPromise(hook: StubHook): ExportId {\r\n    return this.exportStub(hook);\r\n  }\r\n  getImport(hook: StubHook): ImportId | undefined {\r\n    return this.capture(hook);\r\n  }\r\n\r\n  unexport(ids: Array<ExportId>): void {\r\n    // Presumably this MapBuilder is cooked anyway, so we don't really have to release anything.\r\n  }\r\n\r\n  onSendError(error: Error): Error | void {\r\n    // TODO(someday): Can we use the error-sender hook from the RPC system somehow?\r\n  }\r\n};\r\n\r\nmapImpl.sendMap = (hook: StubHook, path: PropertyPath, func: (promise: RpcPromise) => unknown) => {\r\n  let builder = new MapBuilder(hook, path);\r\n  let result: RpcPayload;\r\n  try {\r\n    result = RpcPayload.fromAppReturn(withCallInterceptor(builder.pushCall.bind(builder), () => {\r\n      return func(new RpcPromise(builder.makeInput(), []));\r\n    }));\r\n  } finally {\r\n    builder.unregister();\r\n  }\r\n\r\n  // Detect misuse: Map callbacks cannot be async.\r\n  if (result instanceof Promise) {\r\n    // Squelch unhandled rejections from the map function itself -- it'll probably just throw\r\n    // something about pulling a MapVariableHook.\r\n    result.catch(err => {});\r\n\r\n    // Throw an understandable error.\r\n    throw new Error(\"RPC map() callbacks cannot be async.\");\r\n  }\r\n\r\n  return new RpcPromise(builder.makeOutput(result), []);\r\n}\r\n\r\nfunction throwMapperBuilderUseError(): never {\r\n  throw new Error(\r\n      \"Attempted to use an abstract placeholder from a mapper function. Please make sure your \" +\r\n      \"map function has no side effects.\");\r\n}\r\n\r\n// StubHook which represents a variable in a map function.\r\nclass MapVariableHook extends StubHook {\r\n  constructor(public mapper: MapBuilder, public idx: number) {\r\n    super();\r\n  }\r\n\r\n  // We don't have anything we actually need to dispose, so dup() can just return the same hook.\r\n  dup(): StubHook { return this; }\r\n  dispose(): void {}\r\n\r\n  get(path: PropertyPath): StubHook {\r\n    // This can actually be invoked as part of serialization, so we'll need to support it.\r\n    if (path.length == 0) {\r\n      // Since this hook cannot be pulled anyway, and dispose() is a no-op, we can actually just\r\n      // return the same hook again to represent getting the empty path.\r\n      return this;\r\n    } else if (currentMapBuilder) {\r\n      return currentMapBuilder.pushGet(this, path);\r\n    } else {\r\n      throwMapperBuilderUseError();\r\n    }\r\n  }\r\n\r\n  // Other methods should never be called.\r\n  call(path: PropertyPath, args: RpcPayload): StubHook {\r\n    // Can't be called; all calls are intercepted.\r\n    throwMapperBuilderUseError();\r\n  }\r\n\r\n  map(path: PropertyPath, captures: StubHook[], instructions: unknown[]): StubHook {\r\n    // Can't be called; all map()s are intercepted.\r\n    throwMapperBuilderUseError();\r\n  }\r\n\r\n  pull(): RpcPayload | Promise<RpcPayload> {\r\n    // Map functions cannot await.\r\n    throwMapperBuilderUseError();\r\n  }\r\n\r\n  ignoreUnhandledRejections(): void {\r\n    // Probably never called but whatever.\r\n  }\r\n\r\n  onBroken(callback: (error: any) => void): void {\r\n    throwMapperBuilderUseError();\r\n  }\r\n}\r\n\r\n// =======================================================================================\r\n\r\nclass MapApplicator implements Importer {\r\n  private variables: StubHook[];\r\n\r\n  constructor(private captures: StubHook[], input: StubHook) {\r\n    this.variables = [input];\r\n  }\r\n\r\n  dispose() {\r\n    for (let variable of this.variables) {\r\n      variable.dispose();\r\n    }\r\n  }\r\n\r\n  apply(instructions: unknown[]): RpcPayload {\r\n    try {\r\n      if (instructions.length < 1) {\r\n        throw new Error(\"Invalid empty mapper function.\");\r\n      }\r\n\r\n      for (let instruction of instructions.slice(0, -1)) {\r\n        let payload = new Evaluator(this).evaluateCopy(instruction);\r\n\r\n        // The payload almost always contains a single stub. As an optimization, unwrap it.\r\n        if (payload.value instanceof RpcStub) {\r\n          let hook = unwrapStubNoProperties(payload.value);\r\n          if (hook) {\r\n            this.variables.push(hook);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        this.variables.push(new PayloadStubHook(payload));\r\n      }\r\n\r\n      return new Evaluator(this).evaluateCopy(instructions[instructions.length - 1]);\r\n    } finally {\r\n      for (let variable of this.variables) {\r\n        variable.dispose();\r\n      }\r\n    }\r\n  }\r\n\r\n  importStub(idx: ImportId): StubHook {\r\n    // This implies we saw an \"export\" appear inside the body of a mapper function. This should be\r\n    // impossible because exportStub()/exportPromise() throw exceptions in MapBuilder.\r\n    throw new Error(\"A mapper function cannot refer to exports.\");\r\n  }\r\n  importPromise(idx: ImportId): StubHook {\r\n    return this.importStub(idx);\r\n  }\r\n\r\n  getExport(idx: ExportId): StubHook | undefined {\r\n    if (idx < 0) {\r\n      return this.captures[-idx - 1];\r\n    } else {\r\n      return this.variables[idx];\r\n    }\r\n  }\r\n}\r\n\r\nfunction applyMapToElement(input: unknown, parent: object | undefined, owner: RpcPayload | null,\r\n                           captures: StubHook[], instructions: unknown[]): RpcPayload {\r\n  // TODO(perf): I wonder if we could use .fromAppParams() instead of .deepCopyFrom()? It\r\n  //   maybe wouldn't correctly handle the case of RpcTargets in the input, so we need a variant\r\n  //   which takes an `owner`, which does add some complexity.\r\n  let inputHook = new PayloadStubHook(RpcPayload.deepCopyFrom(input, parent, owner));\r\n  let mapper = new MapApplicator(captures, inputHook);\r\n  try {\r\n    return mapper.apply(instructions);\r\n  } finally {\r\n    mapper.dispose();\r\n  }\r\n}\r\n\r\nmapImpl.applyMap = (input: unknown, parent: object | undefined, owner: RpcPayload | null,\r\n                    captures: StubHook[], instructions: unknown[]) => {\r\n  try {\r\n    let result: RpcPayload;\r\n    if (input instanceof RpcPromise) {\r\n      // The caller is responsible for making sure the input is not a promise, since we can't\r\n      // then know if it would resolve to an array later.\r\n      throw new Error(\"applyMap() can't be called on RpcPromise\");\r\n    } else if (input instanceof Array) {\r\n      let payloads: RpcPayload[] = [];\r\n      try {\r\n        for (let elem of input) {\r\n          payloads.push(applyMapToElement(elem, input, owner, captures, instructions));\r\n        }\r\n      } catch (err) {\r\n        for (let payload of payloads) {\r\n          payload.dispose();\r\n        }\r\n        throw err;\r\n      }\r\n\r\n      result = RpcPayload.fromArray(payloads);\r\n    } else if (input === null || input === undefined) {\r\n      result = RpcPayload.fromAppReturn(input);\r\n    } else {\r\n      result = applyMapToElement(input, parent, owner, captures, instructions);\r\n    }\r\n\r\n    // TODO(perf): We should probably return a hook that allows pipelining but whose pull() doesn't\r\n    //   resolve until all promises in the payload have been substituted.\r\n    return new PayloadStubHook(result);\r\n  } finally {\r\n    for (let cap of captures) {\r\n      cap.dispose();\r\n    }\r\n  }\r\n}\r\n\r\nexport function forceInitMap() {}\r\n","// Copyright (c) 2025 Cloudflare, Inc.\r\n// Licensed under the MIT license found in the LICENSE.txt file or at:\r\n//     https://opensource.org/license/mit\r\n\r\nimport { RpcTarget as RpcTargetImpl, RpcStub as RpcStubImpl, RpcPromise as RpcPromiseImpl } from \"./core.js\";\r\nimport { serialize, deserialize } from \"./serialize.js\";\r\nimport { RpcTransport, RpcSession as RpcSessionImpl, RpcSessionOptions } from \"./rpc.js\";\r\nimport { RpcTargetBranded, Serializable, Stub, Stubify, __RPC_TARGET_BRAND } from \"./types.js\";\r\nimport { newWebSocketRpcSession as newWebSocketRpcSessionImpl,\r\n         newWorkersWebSocketRpcResponse } from \"./websocket.js\";\r\nimport { newHttpBatchRpcSession as newHttpBatchRpcSessionImpl,\r\n         newHttpBatchRpcResponse, nodeHttpBatchRpcResponse } from \"./batch.js\";\r\nimport { newMessagePortRpcSession as newMessagePortRpcSessionImpl } from \"./messageport.js\";\r\nimport { forceInitMap } from \"./map.js\";\r\n\r\nforceInitMap();\r\n\r\n// Re-export public API types.\r\nexport { serialize, deserialize, newWorkersWebSocketRpcResponse, newHttpBatchRpcResponse,\r\n         nodeHttpBatchRpcResponse };\r\nexport type { RpcTransport, RpcSessionOptions };\r\n\r\n// Hack the type system to make RpcStub's types work nicely!\r\n/**\r\n * Represents a reference to a remote object, on which methods may be remotely invoked via RPC.\r\n *\r\n * `RpcStub` can represent any interface (when using TypeScript, you pass the specific interface\r\n * type as `T`, but this isn't known at runtime). The way this works is, `RpcStub` is actually a\r\n * `Proxy`. It makes itself appear as if every possible method / property name is defined. You can\r\n * invoke any method name, and the invocation will be sent to the server. If it turns out that no\r\n * such method exists on the remote object, an exception is thrown back. But the client does not\r\n * actually know, until that point, what methods exist.\r\n */\r\nexport type RpcStub<T extends Serializable<T>> = Stub<T>;\r\nexport const RpcStub: {\r\n  new <T extends Serializable<T>>(value: T): RpcStub<T>;\r\n} = <any>RpcStubImpl;\r\n\r\n/**\r\n * Represents the result of an RPC call.\r\n *\r\n * Also used to represent properties. That is, `stub.foo` evaluates to an `RpcPromise` for the\r\n * value of `foo`.\r\n *\r\n * This isn't actually a JavaScript `Promise`. It does, however, have `then()`, `catch()`, and\r\n * `finally()` methods, like `Promise` does, and because it has a `then()` method, JavaScript will\r\n * allow you to treat it like a promise, e.g. you can `await` it.\r\n *\r\n * An `RpcPromise` is also a proxy, just like `RpcStub`, where calling methods or awaiting\r\n * properties will make a pipelined network request.\r\n *\r\n * Note that and `RpcPromise` is \"lazy\": the actual final result is not requested from the server\r\n * until you actually `await` the promise (or call `then()`, etc. on it). This is an optimization:\r\n * if you only intend to use the promise for pipelining and you never await it, then there's no\r\n * need to transmit the resolution!\r\n */\r\nexport type RpcPromise<T extends Serializable<T>> = Stub<T> & Promise<Stubify<T>>;\r\nexport const RpcPromise: {\r\n  // Note: Cannot construct directly!\r\n} = <any>RpcPromiseImpl;\r\n\r\n/**\r\n * Use to construct an `RpcSession` on top of a custom `RpcTransport`.\r\n *\r\n * Most people won't use this. You only need it if you've implemented your own `RpcTransport`.\r\n */\r\nexport interface RpcSession<T extends Serializable<T> = undefined> {\r\n  getRemoteMain(): RpcStub<T>;\r\n  getStats(): {imports: number, exports: number};\r\n\r\n  // Waits until the peer is not waiting on any more promise resolutions from us. This is useful\r\n  // in particular to decide when a batch is complete.\r\n  drain(): Promise<void>;\r\n}\r\nexport const RpcSession: {\r\n  new <T extends Serializable<T> = undefined>(\r\n      transport: RpcTransport, localMain?: any, options?: RpcSessionOptions): RpcSession<T>;\r\n} = <any>RpcSessionImpl;\r\n\r\n// RpcTarget needs some hackage too to brand it properly and account for the implementation\r\n// conditionally being imported from \"cloudflare:workers\".\r\n/**\r\n * Classes which are intended to be passed by reference and called over RPC must extend\r\n * `RpcTarget`. A class which does not extend `RpcTarget` (and which doesn't have built-in support\r\n * from the RPC system) cannot be passed in an RPC message at all; an exception will be thrown.\r\n *\r\n * Note that on Cloudflare Workers, this `RpcTarget` is an alias for the one exported from the\r\n * \"cloudflare:workers\" module, so they can be used interchangably.\r\n */\r\nexport interface RpcTarget extends RpcTargetBranded {};\r\nexport const RpcTarget: {\r\n  new(): RpcTarget;\r\n} = RpcTargetImpl;\r\n\r\n/**\r\n * Empty interface used as default type parameter for sessions where the other side doesn't\r\n * necessarily export a main interface.\r\n */\r\ninterface Empty {}\r\n\r\n/**\r\n * Start a WebSocket session given either an already-open WebSocket or a URL.\r\n *\r\n * @param webSocket Either the `wss://` URL to connect to, or an already-open WebSocket object to\r\n * use.\r\n * @param localMain The main RPC interface to expose to the peer. Returns a stub for the main\r\n * interface exposed from the peer.\r\n */\r\nexport let newWebSocketRpcSession:<T extends Serializable<T> = Empty>\r\n    (webSocket: WebSocket | string, localMain?: any, options?: RpcSessionOptions) => RpcStub<T> =\r\n    <any>newWebSocketRpcSessionImpl;\r\n\r\n/**\r\n * Initiate an HTTP batch session from the client side.\r\n *\r\n * The parameters to this method have exactly the same signature as `fetch()`, but the return\r\n * value is an RpcStub. You can customize anything about the request except for the method\r\n * (it will always be set to POST) and the body (which the RPC system will fill in).\r\n */\r\nexport let newHttpBatchRpcSession:<T extends Serializable<T>>\r\n    (urlOrRequest: string | Request, init?: RequestInit) => RpcStub<T> =\r\n    <any>newHttpBatchRpcSessionImpl;\r\n\r\n/**\r\n * Initiate an RPC session over a MessagePort, which is particularly useful for communicating\r\n * between an iframe and its parent frame in a browser context. Each side should call this function\r\n * on its own end of the MessageChannel.\r\n */\r\nexport let newMessagePortRpcSession:<T extends Serializable<T> = Empty>\r\n    (port: MessagePort, localMain?: any, options?: RpcSessionOptions) => RpcStub<T> =\r\n    <any>newMessagePortRpcSessionImpl;\r\n\r\n/**\r\n * Implements unified handling of HTTP-batch and WebSocket responses for the Cloudflare Workers\r\n * Runtime.\r\n *\r\n * SECURITY WARNING: This function accepts cross-origin requests. If you do not want this, you\r\n * should validate the `Origin` header before calling this, or use `newHttpBatchRpcSession()` and\r\n * `newWebSocketRpcSession()` directly with appropriate security measures for each type of request.\r\n * But if your API uses in-band authorization (i.e. it has an RPC method that takes the user's\r\n * credentials as parameters and returns the authorized API), then cross-origin requests should\r\n * be safe.\r\n */\r\nexport async function newWorkersRpcResponse(request: Request, localMain: any) {\r\n  if (request.method === \"POST\") {\r\n    let response = await newHttpBatchRpcResponse(request, localMain);\r\n    // Since we're exposing the same API over WebSocket, too, and WebSocket always allows\r\n    // cross-origin requests, the API necessarily must be safe for cross-origin use (e.g. because\r\n    // it uses in-band authorization, as recommended in the readme). So, we might as well allow\r\n    // batch requests to be made cross-origin as well.\r\n    response.headers.set(\"Access-Control-Allow-Origin\", \"*\");\r\n    return response;\r\n  } else if (request.headers.get(\"Upgrade\")?.toLowerCase() === \"websocket\") {\r\n    return newWorkersWebSocketRpcResponse(request, localMain);\r\n  } else {\r\n    return new Response(\"This endpoint only accepts POST or WebSocket requests.\", { status: 400 });\r\n  }\r\n}\r\n"]}